
<img src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhHhnIC5wh8NojPDIbxCx3wyeM16iFH4uBNphGTfeqG7xuyqC_EqTrb5USYeAR90qWeh18I3tQmjILUCnrDG7gWsDvmKryfi598NhyphenhyphenhmJMY-SrMLrc8MO_TdHyWV9ObaXpqfiB77OVZaKlSi25RyYAW2XFyEOkP2g5n2uodhe17vFRTNMVNj6u6d2VkhuI/s16000/bubsort.png"/>

<!-- Bubble Sort Visualizer — Blogger Post -->
<div style="font-family:Inter,system-ui,-apple-system,'Segoe UI',Roboto,Arial; color:#222; line-height:1.55;">

  <h2 style="color:#0a66c2; margin-bottom:6px;">Bubble Sort Visualizer — three modes + early exit</h2>

  <p>
    This interactive demo shows Bubble Sort visually with spoken comparisons and swaps.
    Use the controls to create the boxes and run the sort in one of three modes:
  </p>
  <ul>
    <li><strong>Left → Right</strong> — classic direction (compare i and i+1 left to right).</li>
    <li><strong>Right → Left</strong> — mirror direction (compare i and i-1 right to left).</li>
    <li><strong>Alternating</strong> — odd passes left→right, even passes right→left (cocktail-shaker style).</li>
  </ul>

  <p style="font-size:14px; color:#555;">
    Sorting will end early if a complete pass makes <em>no swaps</em> (i.e., array already sorted).
  </p>

  <!-- Controls -->
  <div id="crx_controls" style="margin-bottom:12px; display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
    <label style="font-weight:700;">Numbers:</label>
    <input id="crx_numbers" type="text" value="1,6,0,1,1,9,7,0" style="min-width:320px; padding:8px; border-radius:6px; border:1px solid #ccc;"></input>

    <button id="crx_createBtn" style="padding:8px 12px; border-radius:6px; border:1px solid #0b63d4; background:#0b63d4; color:#fff; cursor:pointer;">Create Boxes</button>
    <button id="crx_sortBtn" style="padding:8px 12px; border-radius:6px; border:1px solid #0b63d4; background:#0b63d4; color:#fff; cursor:pointer;">Run Bubble Sort</button>

    <label style="margin-left:8px; display:flex; gap:6px; align-items:center;">
      <input id="crx_speechToggle" type="checkbox" checked="checked"></input>
      <span style="font-weight:600;">Speak (comparisons & swaps)</span>
    </label>

    <label style="margin-left:8px; display:flex; gap:6px; align-items:center;">
      <span style="font-weight:600;">Mode:</span>
      <select id="crx_mode" style="padding:6px 8px; border-radius:6px; border:1px solid #ccc;">
        <option value="ltr">Left → Right</option>
        <option value="rtl">Right → Left</option>
        <option value="alt">Alternating (L→R then R→L)</option>
      </select>
    </label>
  </div>

  <!-- Visual container -->
  <div id="crx_container" style="position:relative; width:100%; height:220px; border:2px solid #333; margin-top:10px; overflow-x:auto; padding:10px; box-sizing:border-box; background:#fafafa;">
    <div class="crx_spacer" style="height:160px;"></div>
  </div>

  <!-- speech caption + queue -->
  <div id="crx_speechBar" aria-live="polite" style="margin-top:16px; padding:10px; background:#0b63d4; color:#fff; border-radius:6px; min-height:46px; display:flex; flex-direction:column; gap:6px;">
    <div id="crx_speechCurrent" style="font-size:18px; font-weight:700; text-align:center; letter-spacing:0.4px;">Ready...</div>
    <div id="crx_speechQueue" style="font-size:13px; opacity:0.95; text-align:center;"></div>
  </div>

  <!-- short explanation / pseudocode -->
  <h3 style="color:#0a66c2; margin-top:14px;">How it works (pseudocode)</h3>
  <div style="background:#f9f9fb; padding:10px; border-radius:6px; border:1px solid #eef2f7;">
<pre style="margin:0; font-family:monospace;">
repeat until no swaps in a full pass:
  if mode == left-to-right:
    for i from 0 to n-2:
      compare a[i] and a[i+1]; swap if needed
  else if mode == right-to-left:
    for i from n-1 down to 1:
      compare a[i] and a[i-1]; swap if needed
  else if mode == alternating:
    on odd pass do left-to-right, on even pass do right-to-left
</pre>
  </div>

</div>

<!-- Inline script for visualization (paste this entire block in the post's HTML) -->
<script>
(function(){
  // DOM refs
  const container = document.getElementById('crx_container');
  const createBtn = document.getElementById('crx_createBtn');
  const sortBtn = document.getElementById('crx_sortBtn');
  const input = document.getElementById('crx_numbers');
  const speechToggle = document.getElementById('crx_speechToggle');
  const speechCurrent = document.getElementById('crx_speechCurrent');
  const speechQueueDiv = document.getElementById('crx_speechQueue');
  const modeSelect = document.getElementById('crx_mode');

  // state
  let boxes = [];    // DOM elements
  let values = [];   // numeric values
  let busy = false;
  let needRecenter = false;
  let phraseQueue = [];

  // layout/timings
  const spacing = 80;
  const ypos = 60;
  const stageMs = 420;
  const swapTotalMs = stageMs * 3;
  const compareMs = 900; // comparison duration

  // helpers: color mapping
  function numberToColorMagnitude(magnitude, maxAbs) {
    if (maxAbs === 0) return { r: 80, g: 130, b: 220 };
    let t = magnitude / maxAbs;
    return {
      r: Math.round(t * 255),
      g: Math.round((1 - Math.abs(t - 0.5) * 2) * 255),
      b: Math.round((1 - t) * 255)
    };
  }
  function invertColor({ r, g, b }) { return { r: 255 - r, g: 255 - g, b: 255 - b }; }
  function rgbToString({ r, g, b }) { return `rgb(${r},${g},${b})`; }

  // centering
  function computeOffset() {
    const totalWidth = values.length * spacing;
    const containerWidth = container.clientWidth;
    return Math.max(0, (containerWidth - totalWidth) / 2);
  }
  function slotLeft(index) { return computeOffset() + index * spacing; }

  // speech UI
  function updateSpeechBarUI() {
    if (phraseQueue.length === 0) {
      speechCurrent.textContent = 'Ready...';
      speechQueueDiv.innerHTML = '';
      return;
    }
    speechCurrent.textContent = phraseQueue[0] || '';
    if (phraseQueue.length > 1) {
      const upcoming = phraseQueue.slice(1, 7).map((p, i) => `<span class="upcoming" style="display:block; color: rgba(255,255,255,0.9);">${i+1}. ${escapeHtml(p)}</span>`).join('');
      speechQueueDiv.innerHTML = upcoming;
    } else {
      speechQueueDiv.innerHTML = '';
    }
  }
  function escapeHtml(s) { return String(s).replace(/[&<>"']/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }
  function enqueuePhrase(phrase){ phraseQueue.push(phrase); updateSpeechBarUI(); }
  function dequeuePhrase(){ phraseQueue.shift(); updateSpeechBarUI(); }

  // speak with duration target
  function speakPhraseForDuration(phrase, targetMs){
    enqueuePhrase(phrase);
    return new Promise(resolve => {
      if (!speechToggle.checked || typeof speechSynthesis === 'undefined') {
        setTimeout(()=>{ dequeuePhrase(); resolve(); }, Math.max(30, targetMs));
        return;
      }
      const words = phrase.trim().split(/\s+/).length || 1;
      const estMsAtRate1 = (words / 3) * 1000;
      let rate = estMsAtRate1 / targetMs;
      if (rate < 0.35) rate = 0.35; if (rate > 2.5) rate = 2.5;
      const u = new SpeechSynthesisUtterance(phrase);
      u.rate = rate;
      const voices = speechSynthesis.getVoices();
      if (voices && voices.length) {
        const v = voices.find(v => /en-|english/i.test(v.name)) || voices[0];
        if (v) u.voice = v;
      }
      u.onend = ()=>{ dequeuePhrase(); resolve(); };
      u.onerror = ()=>{ dequeuePhrase(); resolve(); };
      speechSynthesis.speak(u);
    });
  }

  // utilities
  function delay(ms){ return new Promise(r=>setTimeout(r, ms)); }
  function refreshIndices(){ boxes.forEach((b,i)=>{ const lbl=b.querySelector('.idx'); if(lbl) lbl.textContent=i; }); }
  function currentLeftRelToContainer(elem){
    const rect = elem.getBoundingClientRect();
    const cont = container.getBoundingClientRect();
    return rect.left - cont.left + container.scrollLeft;
  }

  // create boxes
  function createBoxes(){
    const raw = input.value.split(',').map(s=>s.trim()).filter(s=>s.length>0);
    const parsed = raw.map(s=>Number(s)).filter(n=>!Number.isNaN(n));
    if (parsed.length===0){ alert('Enter at least one number'); return; }
    container.innerHTML = '<div class="crx_spacer" style="height:160px;"></div>';
    boxes=[]; values=[];
    const maxAbs = Math.max(...parsed.map(n=>Math.abs(n)));
    parsed.forEach((val, idx)=>{
      const mag = Math.abs(val);
      const posBg = numberToColorMagnitude(mag, maxAbs);
      const posText = invertColor(posBg);
      const bg = val >= 0 ? posBg : posText;
      const fg = val >= 0 ? posText : posBg;

      const box = document.createElement('div');
      box.className = 'crx_box';
      box.textContent = val;
      box.style.position = 'absolute';
      box.style.width = '56px';
      box.style.height = '56px';
      box.style.display = 'flex';
      box.style.alignItems = 'center';
      box.style.justifyContent = 'center';
      box.style.borderRadius = '8px';
      box.style.fontWeight = '700';
      box.style.transition = 'transform 0.35s ease, box-shadow 0.35s ease, left 0.25s ease';
      box.style.userSelect = 'none';
      box.style.boxShadow = '0 6px 14px rgba(0,0,0,0.08)';
      box.style.left = slotLeft(idx) + 'px';
      box.style.top = ypos + 'px';
      box.style.background = rgbToString(bg);
      box.style.color = rgbToString(fg);

      const lbl = document.createElement('div');
      lbl.className = 'idx';
      lbl.style.position = 'absolute';
      lbl.style.right = '-10px';
      lbl.style.top = '-10px';
      lbl.style.fontSize = '10px';
      lbl.style.background = 'rgba(255,255,255,0.85)';
      lbl.style.padding = '2px 4px';
      lbl.style.borderRadius = '6px';
      lbl.style.border = '1px solid rgba(0,0,0,0.06)';
      lbl.style.fontWeight = '600';
      lbl.textContent = idx;
      box.appendChild(lbl);

      container.appendChild(box);
      boxes.push(box);
      values.push(val);
    });

    container.style.minWidth = (parsed.length * spacing + 20) + 'px';
    phraseQueue = [];
    updateSpeechBarUI();
    recenterBoxes();
  }

  // visual helpers
  function addHighlight(el){ el.classList.add('crx_highlight'); el.style.transform='scale(1.08)'; el.style.boxShadow='0 10px 26px rgba(11,99,212,0.24)'; }
  function removeHighlight(el){ el.classList.remove('crx_highlight'); el.style.transform=''; el.style.boxShadow='0 6px 14px rgba(0,0,0,0.08)'; }

  function commitBoxToSlotWithoutJump(box, targetSlotLeftPx){
    const curLeft = currentLeftRelToContainer(box);
    const fix = curLeft - targetSlotLeftPx;
    box.style.transition = 'none';
    box.style.left = Math.round(targetSlotLeftPx) + 'px';
    box.style.transform = `translate(${Math.round(fix)}px, 0px)`;
    void box.offsetWidth;
    box.style.transform = '';
    void box.offsetWidth;
    box.style.transition = 'transform 0.35s ease, box-shadow 0.35s ease, left 0.25s ease';
  }

  // highlight and speak comparison
  async function highlightAndSpeakCompare(i, j){
    if (i<0||j<0||i>=boxes.length||j>=boxes.length) return;
    const a = boxes[i], b = boxes[j];
    const phrase = `Comparing ${values[i]} and ${values[j]}`;
    addHighlight(a); addHighlight(b);
    const sp = speakPhraseForDuration(phrase, compareMs);
    await delay(compareMs);
    removeHighlight(a); removeHighlight(b);
    await sp;
  }

  // swap animation with speech
  async function swapAnimationSpeak(i, j){
    if (i===j) return;
    const boxA = boxes[i], boxB = boxes[j];
    const valA = values[i], valB = values[j];
    const leftA = slotLeft(i), leftB = slotLeft(j);
    const dAB = leftB - leftA, dBA = leftA - leftB;
    const phrase = `Swapping ${valA} and ${valB}`;
    const speechPromise = speakPhraseForDuration(phrase, swapTotalMs);

    // up
    boxA.style.transition = `transform ${stageMs/1000}s ease`;
    boxB.style.transition = `transform ${stageMs/1000}s ease`;
    boxA.style.transform = 'translateY(-70px)';
    boxB.style.transform = 'translateY(-70px)';
    await delay(stageMs);

    // cross
    boxA.style.transform = `translate(${dAB}px, -70px)`;
    boxB.style.transform = `translate(${dBA}px, -70px)`;
    await delay(stageMs);

    // down
    boxA.style.transform = `translate(${dAB}px, 0px)`;
    boxB.style.transform = `translate(${dBA}px, 0px)`;
    await delay(stageMs);

    await speechPromise;

    // commit positions without jump
    const targetLeftA = slotLeft(j);
    const targetLeftB = slotLeft(i);
    commitBoxToSlotWithoutJump(boxA, targetLeftA);
    commitBoxToSlotWithoutJump(boxB, targetLeftB);

    // swap logical arrays
    [boxes[i], boxes[j]] = [boxes[j], boxes[i]];
    [values[i], values[j]] = [values[j], values[i]];
    refreshIndices();

    if (needRecenter) { needRecenter=false; recenterBoxes(); }
  }

  // recenter
  function recenterBoxes(){
    if (boxes.length===0) return;
    if (busy) { needRecenter=true; return; }
    boxes.forEach((box, idx)=>{ box.style.transition='none'; box.style.left = Math.round(slotLeft(idx)) + 'px'; });
    void container.offsetWidth;
    boxes.forEach(box=>{ box.style.transition = 'transform 0.35s ease, box-shadow 0.35s ease, left 0.25s ease'; });
  }

  // bubble sort driver with three modes and early exit when no swaps in a full pass
  async function bubbleSort(){
    if (busy) return;
    if (values.length < 2) return;
    busy = true; createBtn.disabled = true; sortBtn.disabled = true;

    const n = values.length;
    let pass = 0;
    let swappedThisPass = true;

    while (pass < n - 1 && swappedThisPass) {
      swappedThisPass = false;
      // determine direction for this pass
      const mode = modeSelect.value; // 'ltr', 'rtl', 'alt'
      let dir = 'ltr';
      if (mode === 'ltr') dir = 'ltr';
      else if (mode === 'rtl') dir = 'rtl';
      else if (mode === 'alt') dir = (pass % 2 === 0) ? 'ltr' : 'rtl';

      if (dir === 'ltr') {
        // i = 0 .. n-2-pass
        for (let i = 0; i < n - 1 - pass; i++) {
          await highlightAndSpeakCompare(i, i+1);
          if (values[i] > values[i+1]) {
            await swapAnimationSpeak(i, i+1);
            swappedThisPass = true;
          }
        }
      } else {
        // dir === 'rtl'
        // i = n-1 .. 1+pass
        for (let i = n - 1; i > pass; i--) {
          await highlightAndSpeakCompare(i, i-1);
          if (values[i-1] > values[i]) {
            // swap positions i-1 and i (which are adjacent)
            await swapAnimationSpeak(i-1, i);
            swappedThisPass = true;
          }
        }
      }

      pass++;
      // If no swap happened in this whole pass, early exit
      if (!swappedThisPass) break;
    }

    busy = false; createBtn.disabled = false; sortBtn.disabled = false;
    // final highlight to show sorted
    boxes.forEach(b => { addHighlight(b); });
    setTimeout(()=> boxes.forEach(b => removeHighlight(b)), 600);

    phraseQueue = ['Sorting complete!']; updateSpeechBarUI();
    setTimeout(()=>{ phraseQueue = []; updateSpeechBarUI(); }, 1600);

    alert('Sorting complete!');
  }

  // events
  createBtn.addEventListener('click', createBoxes);
  sortBtn.addEventListener('click', bubbleSort);

  // recenter on resize
  let resizeTimer = null;
  window.addEventListener('resize', ()=>{ clearTimeout(resizeTimer); resizeTimer = setTimeout(()=>{ if (busy) needRecenter=true; else recenterBoxes(); }, 120); });

  // init
  createBoxes();

})();
</script>