<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Champak Roy ‚Äî Whiteboard (fixed)</title>
<style>
  :root{--blue:#3f6bff;--bg:#eef3ff;--panel:#fff;--muted:#c7d6ff}
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;font-family:Arial,Helvetica,sans-serif;background:var(--bg)}
  .center{min-height:100vh;display:flex;align-items:center;justify-content:center;padding:14px}
  .board-container{width:95%;max-width:1200px;height:86vh;background:var(--panel);border:3px solid var(--blue);border-radius:12px;box-shadow:0 8px 30px rgba(0,0,0,0.08);position:relative;overflow:hidden;display:flex;flex-direction:column}
  .toolbar{display:flex;gap:8px;align-items:center;padding:10px}
  .tool-group{display:flex;gap:8px;align-items:center;padding:6px;border-radius:8px;background:rgba(255,255,255,0.95);border:1px solid var(--muted)}
  button, input[type=range], input[type=color]{font-size:13px;padding:6px 8px;border-radius:6px;border:1px solid #e6eefc;cursor:pointer;background:#fbfdff}
  button.small{padding:6px}
  button.active{background:rgba(63,107,255,0.12);color:var(--blue)}
  .spacer{flex:1}
  .canvas-wrap{position:relative;flex:1;display:block;background:#fff}
  canvas#board{position:absolute;left:0;top:0;width:100%;height:100%;touch-action:none;display:block;cursor:crosshair}
  .text-note{position:absolute;min-width:120px;min-height:28px;padding:6px 8px;border-radius:6px;border:1px dashed rgba(0,0,0,0.12);background:rgba(255,255,255,0.96);resize:both;overflow:auto;font-size:16px}
  .laser{position:absolute;pointer-events:none;border-radius:50%;width:28px;height:28px;margin-left:-14px;margin-top:-14px;box-shadow:0 0 12px rgba(255,0,0,0.45);display:none;z-index:120}
  .eraser-cursor{position:absolute;pointer-events:none;border-radius:50%;border:2px dashed rgba(0,0,0,0.25);transform:translate(-50%,-50%);display:none;z-index:130}
  .playbackProgress{width:160px;height:8px;background:rgba(0,0,0,0.06);border-radius:6px;overflow:hidden}
  .playbackBar{height:100%;width:0;background:linear-gradient(90deg,var(--blue),#7cc0ff)}
  .controls {display:flex;gap:6px;align-items:center}
  .fileInput{display:none}
  .status{font-size:13px;color:#333;padding-left:8px}
  @media(max-width:760px){.desktop-only{display:none}}

  /* GUIDE (bottom-right) */
  .guide {
    position: absolute;
    bottom: 12px;
    right: 12px;
    width: 320px;
    max-width: calc(100% - 28px);
    background: linear-gradient(180deg, rgba(255,255,255,0.98), rgba(248,249,255,0.98));
    border: 1px solid rgba(99,123,255,0.12);
    box-shadow: 0 10px 30px rgba(31,41,55,0.08);
    border-radius: 10px;
    z-index: 200;
    overflow: hidden;
    font-size: 13px;
  }
  .guide .head { display:flex; align-items:center; justify-content:space-between; gap:8px; padding:8px 10px; background: rgba(255,255,255,0.9); border-bottom:1px solid rgba(0,0,0,0.03); }
  .guide .title { font-weight:600; color:#14213d; }
  .guide .content { padding:10px; line-height:1.4; color:#222; max-height: 360px; overflow:auto; }
  .guide .footer { padding:8px 10px; border-top:1px solid rgba(0,0,0,0.03); background: rgba(255,255,255,0.96); display:flex; justify-content:space-between; align-items:center; gap:8px; }
  .guide.collapsed { width:44px; height:44px; border-radius:50%; overflow:visible; padding:0; right:12px; bottom:12px; }
  .guide.collapsed .head { display:flex; justify-content:center; align-items:center; padding:0; border-bottom:none; }
  .guide.collapsed .content, .guide.collapsed .footer { display:none; }
</style>
</head>
<body>

<div class="center">
  <div class="board-container" id="boardContainer">

    <div class="toolbar" role="toolbar" aria-label="Whiteboard toolbar">
      <div class="tool-group" id="mainTools">
        <button id="penBtn" class="active" title="Pen">‚úè Pen</button>
        <button id="highlighterBtn" title="Highlighter">üñç Hl</button>
        <button id="eraserBtn" title="Eraser">üßΩ Erase</button>
        <button id="textBtn" title="Text">T</button>

        <label>Color</label><input type="color" id="color" value="#000000">
        <label>Size</label><input type="range" id="size" min="1" max="80" value="8">
        <label>Opacity</label><input type="range" id="opacity" min="0.1" max="1" step="0.05" value="1">

        <button id="clearBtn" title="Clear board">üßπ Clear</button>
      </div>

      <div class="spacer"></div>

      <div class="tool-group">
        <div class="controls">
          <button id="recordBtn" class="small" title="Start recording">‚óè Record</button>
          <button id="stopRecBtn" class="small" title="Stop recording" disabled>‚ñ† Stop</button>

          <button id="playBtn" class="small" title="Play" disabled>‚ñ∂ Play</button>
          <button id="pauseBtn" class="small" title="Pause" disabled>‚è∏ Pause</button>
          <button id="stopPlayBtn" class="small" title="Stop playback" disabled>‚ñ† Stop</button>

          <button id="laserBtn" class="small" title="Toggle laser pointer">üî¥ Laser</button>

          <button id="exportBtn" class="small" title="Export recording" disabled>‚¨á Export</button>
          <label for="importFile" style="padding:0;margin:0"><button id="importBtn" class="small" title="Import recording">‚¨Ü Import</button></label>
          <input type="file" id="importFile" class="fileInput" accept=".json">
        </div>
        <div style="padding-left:8px;display:flex;align-items:center;gap:8px">
          <div class="playbackProgress" title="Playback progress"><div id="playbar" class="playbackBar"></div></div>
          <div class="status" id="status">Ready</div>
        </div>
      </div>
    </div>

    <div class="canvas-wrap" id="canvasWrap">
      <canvas id="board"></canvas>
      <div id="laser" class="laser" style="background: rgba(255,0,0,0.55); display:none"></div>
      <div id="eraserCursor" class="eraser-cursor"></div>
    </div>

    <!-- How to use guide (bottom-right) -->
    <div id="howto" class="guide" role="region" aria-label="How to use whiteboard guide">
      <div class="head">
        <div>
          <div class="title">How to use ‚Äî Whiteboard</div>
          <div style="font-size:11px;color:#445;opacity:0.9">Quick guide</div>
        </div>
        <div>
          <button id="toggleGuide" title="Collapse/expand guide">‚Äì</button>
          <button id="closeGuide" title="Hide guide temporarily">‚úï</button>
        </div>
      </div>

      <div class="content" id="guideContent">
        <h4>Basic steps</h4>
        <ol>
          <li>Select a tool: <strong>Pen</strong>, <strong>Highlighter</strong>, <strong>Eraser</strong>, or <strong>Text</strong>.</li>
          <li>Pick <strong>Color</strong>, adjust <strong>Size</strong> and <strong>Opacity</strong>.</li>
          <li>Draw, add text (click where you want the text box), erase, or clear the board.</li>
        </ol>
        <h4>Highlighter</h4>
        <p>Choose Highlighter, pick a light color (e.g. #ffeb3b), increase Size (20‚Äì60) and lower Opacity (0.25‚Äì0.6) to overlay semi-transparent strokes.</p>
        <h4>Eraser</h4>
        <p>Choose Eraser and move over strokes. A dashed circular cursor shows the erase radius (Size controls it). Clear removes canvas + text boxes.</p>
        <h4>Recording</h4>
        <p>Record ‚Üí Stop ‚Üí Play. Export saves a JSON; Import loads it back. Text boxes are not recorded (strokes only).</p>
      </div>

      <div class="footer">
        <div style="font-size:12px;color:#445">Guide</div>
        <div>
          <button id="pinGuide" title="Pin guide (remember state)">üìå Pin</button>
        </div>
      </div>
    </div>

  </div>
</div>

<script>
/* Clean, tested whiteboard ‚Äî no syntax errors */

(() => {
  // Elements
  const canvas = document.getElementById('board');
  const wrap = document.getElementById('canvasWrap');
  const ctx = canvas.getContext('2d', {alpha:false});
  const penBtn = document.getElementById('penBtn');
  const highlighterBtn = document.getElementById('highlighterBtn');
  const eraserBtn = document.getElementById('eraserBtn');
  const textBtn = document.getElementById('textBtn');
  const colorInput = document.getElementById('color');
  const sizeInput = document.getElementById('size');
  const opacityInput = document.getElementById('opacity');
  const clearBtn = document.getElementById('clearBtn');

  const recordBtn = document.getElementById('recordBtn');
  const stopRecBtn = document.getElementById('stopRecBtn');
  const playBtn = document.getElementById('playBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const stopPlayBtn = document.getElementById('stopPlayBtn');
  const exportBtn = document.getElementById('exportBtn');
  const importFile = document.getElementById('importFile');
  const importBtn = document.getElementById('importBtn');
  const laserBtn = document.getElementById('laserBtn');
  const laserEl = document.getElementById('laser');
  const eraserCursor = document.getElementById('eraserCursor');
  const playbar = document.getElementById('playbar');
  const status = document.getElementById('status');

  // Guide elements
  const guideEl = document.getElementById('howto');
  const toggleGuide = document.getElementById('toggleGuide');
  const closeGuide = document.getElementById('closeGuide');
  const pinGuide = document.getElementById('pinGuide');

  // Canvas sizing + preserve drawing
  function resizeCanvas(){
    const r = wrap.getBoundingClientRect();
    const tmp = document.createElement('canvas');
    tmp.width = canvas.width || Math.max(800, Math.floor(r.width));
    tmp.height = canvas.height || Math.max(400, Math.floor(r.height));
    const tctx = tmp.getContext('2d');
    if(canvas.width && canvas.height) tctx.drawImage(canvas,0,0);
    canvas.width = Math.floor(r.width);
    canvas.height = Math.floor(r.height);
    // white background
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.drawImage(tmp,0,0, tmp.width, tmp.height, 0,0, canvas.width, canvas.height);
  }
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);

  // State
  let tool = 'pen';
  let color = colorInput.value;
  let size = Number(sizeInput.value);
  let opacity = Number(opacityInput.value);
  let drawing = false;
  let lastPointerId = null;
  let points = [];

  // Snapshot/undo (canvas-only)
  let snapshots = [], snapIdx = -1;
  function saveSnapshot(){
    try{
      const data = canvas.toDataURL();
      snapshots = snapshots.slice(0, snapIdx+1);
      snapshots.push(data);
      if(snapshots.length > 30) snapshots.shift();
      snapIdx = snapshots.length - 1;
    }catch(e){}
  }
  function restoreSnapshot(i){
    if(i<0 || i>=snapshots.length) return;
    const img = new Image();
    img.onload = ()=> { ctx.clearRect(0,0,canvas.width,canvas.height); ctx.drawImage(img,0,0,canvas.width,canvas.height); };
    img.src = snapshots[i];
  }
  saveSnapshot();

  // Recording model (simple)
  let isRecording = false;
  let recording = null; // { events:[], duration }
  let recordingMemory = null;
  let recordStart = 0;

  function nowMs(){ return performance.now(); }
  function startRecording(){
    recording = { events: [], duration: 0 };
    isRecording = true;
    recordStart = nowMs();
    recordBtn.disabled = true; stopRecBtn.disabled = false;
    playBtn.disabled = true; exportBtn.disabled = true;
    status.textContent = 'Recording...';
  }
  function stopRecording(){
    if(!isRecording) return;
    isRecording = false;
    recording.duration = Math.max(0, nowMs() - recordStart);
    recordingMemory = recording;
    recordBtn.disabled = false; stopRecBtn.disabled = true;
    playBtn.disabled = recordingMemory.events.length > 0 ? false : true;
    exportBtn.disabled = recordingMemory && recordingMemory.events.length ? false : true;
    status.textContent = `Recorded ${Math.round(recording.duration)} ms`;
  }
  function pushEvent(e){
    if(!isRecording || !recording) return;
    recording.events.push(Object.assign({ t: Math.round(nowMs()-recordStart) }, e));
  }

  // Playback simple controller using timeouts
  let playback = null; // { timers: [], startTime, pausedAt, script }
  function clearPlaybackTimers(){
    if(!playback || !playback.timers) return;
    playback.timers.forEach(id => clearTimeout(id));
    playback = null;
    playbar.style.width = '0%';
    playBtn.disabled = false; pauseBtn.disabled = true; stopPlayBtn.disabled = true;
  }

  function playRecording(){
    if(!recordingMemory || !recordingMemory.events || recordingMemory.events.length === 0) return;
    clearPlaybackTimers();
    const events = recordingMemory.events;
    playback = { timers: [], startTime: nowMs(), script: recordingMemory, playing: true };
    // clear canvas for playback
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,canvas.width,canvas.height);
    let pen = null;
    for(const ev of events){
      const id = setTimeout(() => {
        if(!playback || !playback.playing) return;
        if(ev.type === 'start'){
          pen = { x: ev.x, y: ev.y, tool: ev.tool, color: ev.color, size: ev.size, opacity: ev.opacity };
          ctx.save();
          if(pen.tool === 'eraser'){ ctx.globalCompositeOperation = 'destination-out'; ctx.globalAlpha = 1; }
          else { ctx.globalCompositeOperation = 'source-over'; ctx.globalAlpha = pen.opacity; }
          ctx.lineCap = ctx.lineJoin = 'round';
          ctx.lineWidth = pen.size;
          ctx.beginPath(); ctx.moveTo(pen.x, pen.y); ctx.lineTo(pen.x+0.01, pen.y+0.01); ctx.stroke();
          ctx.restore();
        } else if(ev.type === 'move'){
          if(!pen) return;
          const prev = { x: pen.x, y: pen.y }, curr = { x: ev.x, y: ev.y };
          ctx.save();
          if(pen.tool === 'eraser'){ ctx.globalCompositeOperation = 'destination-out'; ctx.globalAlpha = 1; }
          else { ctx.globalCompositeOperation = 'source-over'; ctx.globalAlpha = pen.opacity; }
          ctx.lineCap = ctx.lineJoin = 'round';
          ctx.lineWidth = pen.size;
          ctx.beginPath(); ctx.moveTo(prev.x, prev.y); ctx.lineTo(curr.x, curr.y); ctx.stroke();
          ctx.restore();
          pen.x = curr.x; pen.y = curr.y;
        } else if(ev.type === 'end'){ pen = null; }
        // progress
        const progress = Math.min(1, (nowMs() - playback.startTime) / (playback.script.duration || 1));
        playbar.style.width = (progress*100) + '%';
        if(progress >= 1){ setTimeout(()=> { clearPlaybackTimers(); status.textContent = 'Playback finished'; saveSnapshot(); }, 20); }
      }, ev.t);
      playback.timers.push(id);
    }
    playBtn.disabled = true; pauseBtn.disabled = false; stopPlayBtn.disabled = false;
    status.textContent = 'Playing...';
  }

  function stopPlayback(){
    if(playback && playback.timers) playback.timers.forEach(id => clearTimeout(id));
    playback = null;
    playbar.style.width = '0%';
    playBtn.disabled = recordingMemory ? false : true;
    pauseBtn.disabled = true; stopPlayBtn.disabled = true;
    status.textContent = 'Ready';
    saveSnapshot();
  }

  // Drawing helpers
  function applyStroke(ctxLocal, mode, col, sz, op){
    ctxLocal.lineCap = 'round';
    ctxLocal.lineJoin = 'round';
    ctxLocal.lineWidth = sz;
    if(mode === 'eraser'){
      ctxLocal.globalCompositeOperation = 'destination-out';
      ctxLocal.globalAlpha = 1;
      ctxLocal.strokeStyle = 'rgba(0,0,0,1)';
    } else {
      ctxLocal.globalCompositeOperation = 'source-over';
      ctxLocal.globalAlpha = op;
      ctxLocal.strokeStyle = col;
    }
  }

  function drawLine(prev, curr, mode, col, sz, op){
    applyStroke(ctx, mode, col, sz, op);
    ctx.beginPath();
    ctx.moveTo(prev.x, prev.y);
    ctx.lineTo(curr.x, curr.y);
    ctx.stroke();
    // restore to default to avoid keeping eraser
    ctx.globalCompositeOperation = 'source-over';
    ctx.globalAlpha = 1;
  }

  // Text notes
  function addTextNoteAt(x,y,html='',w=180,h=40,styles=null){
    const note = document.createElement('div');
    note.className = 'text-note';
    note.contentEditable = true;
    note.innerHTML = html || '';
    note.style.left = x + 'px';
    note.style.top = y + 'px';
    note.style.width = w + 'px';
    note.style.height = h + 'px';
    note.style.zIndex = 110;
    if(styles){ if(styles.fontSize) note.style.fontSize = styles.fontSize; if(styles.color) note.style.color = styles.color; }
    note.addEventListener('blur', ()=> saveSnapshot());
    // dragging
    let dragging = false, start = null, orig = null;
    note.addEventListener('pointerdown', (e) => {
      if(e.button && e.button !== 0) return;
      e.stopPropagation();
      dragging = true;
      start = { x: e.clientX, y: e.clientY };
      const r = note.getBoundingClientRect(), pr = wrap.getBoundingClientRect();
      orig = { left: r.left - pr.left, top: r.top - pr.top };
      note.setPointerCapture && note.setPointerCapture(e.pointerId);
      note.style.touchAction = 'none';
    });
    window.addEventListener('pointermove', (e) => {
      if(!dragging) return;
      const dx = e.clientX - start.x, dy = e.clientY - start.y;
      note.style.left = (orig.left + dx) + 'px';
      note.style.top = (orig.top + dy) + 'px';
    });
    window.addEventListener('pointerup', (e) => {
      if(!dragging) return;
      dragging = false;
      note.releasePointerCapture && note.releasePointerCapture(e.pointerId);
      note.style.touchAction = '';
      saveSnapshot();
    });
    note.addEventListener('dblclick', ()=> { if(confirm('Delete this text box?')) { note.remove(); saveSnapshot(); } });
    wrap.appendChild(note);
    setTimeout(()=> note.focus(), 10);
    return note;
  }

  // Clear board
  function clearBoard(){
    ctx.save();
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.restore();
    document.querySelectorAll('.text-note').forEach(n => n.remove());
    saveSnapshot();
    status.textContent = 'Cleared';
  }

  // Pointer events
  canvas.addEventListener('pointerdown', (e) => {
    // Text tool: create note and stop
    if(tool === 'text'){
      const r = wrap.getBoundingClientRect();
      const x = e.clientX - r.left, y = e.clientY - r.top;
      addTextNoteAt(x, y, '', 220, 36, { fontSize: '16px', color: color });
      e.preventDefault();
      return;
    }
    if(e.button && e.button !== 0) return;
    canvas.setPointerCapture && canvas.setPointerCapture(e.pointerId);
    drawing = true;
    lastPointerId = e.pointerId;
    points = [];
    const p = getPos(e);
    points.push(p);
    pushEvent({ type:'start', tool, color, size, opacity, x:p.x, y:p.y });
    // set composite if eraser
    if(tool === 'eraser'){ ctx.save(); ctx.globalCompositeOperation = 'destination-out'; ctx.globalAlpha = 1; }
    else { ctx.save(); ctx.globalCompositeOperation = 'source-over'; ctx.globalAlpha = opacity; }
    applyStroke(ctx, tool, color, size, opacity);
    ctx.beginPath();
    ctx.moveTo(p.x, p.y);
    ctx.lineTo(p.x+0.01, p.y+0.01);
    ctx.stroke();
    updateEraserCursor(e);
    e.preventDefault();
  }, { passive:false });

  canvas.addEventListener('pointermove', (e) => {
    updateEraserCursor(e);
    if(!drawing || e.pointerId !== lastPointerId) return;
    const p = getPos(e);
    const prev = points[points.length-1];
    points.push(p);
    drawLine(prev, p, tool, color, size, opacity);
    pushEvent({ type:'move', x:p.x, y:p.y });
    e.preventDefault();
  }, { passive:false });

  window.addEventListener('pointerup', (e) => {
    if(!drawing || e.pointerId !== lastPointerId) return;
    drawing = false;
    canvas.releasePointerCapture && canvas.releasePointerCapture(e.pointerId);
    const p = points[points.length-1] || getPos(e);
    pushEvent({ type:'end', x:p.x, y:p.y });
    // restore context (if eraser we saved earlier)
    ctx.restore();
    saveSnapshot();
    e.preventDefault();
  }, { passive:false });

  function getPos(e){
    const r = canvas.getBoundingClientRect();
    return { x: e.clientX - r.left, y: e.clientY - r.top };
  }

  function updateEraserCursor(e){
    if(!eraserCursor) return;
    if(tool !== 'eraser'){ eraserCursor.style.display = 'none'; return; }
    eraserCursor.style.display = 'block';
    const r = wrap.getBoundingClientRect();
    if(e){
      eraserCursor.style.left = (e.clientX - r.left) + 'px';
      eraserCursor.style.top = (e.clientY - r.top) + 'px';
    }
    eraserCursor.style.width = size + 'px';
    eraserCursor.style.height = size + 'px';
    eraserCursor.style.borderRadius = (size/2) + 'px';
  }

  // Tool UI
  function setTool(t){
    tool = t;
    [penBtn, highlighterBtn, eraserBtn, textBtn].forEach(b => b.classList.remove('active'));
    if(t === 'pen') penBtn.classList.add('active');
    if(t === 'highlighter') highlighterBtn.classList.add('active');
    if(t === 'eraser') eraserBtn.classList.add('active');
    if(t === 'text') textBtn.classList.add('active');
    canvas.style.cursor = (t === 'text' ? 'text' : 'crosshair');
    if(t !== 'eraser') eraserCursor.style.display = 'none';
  }
  penBtn.addEventListener('click', ()=> setTool('pen'));
  highlighterBtn.addEventListener('click', ()=> setTool('highlighter'));
  eraserBtn.addEventListener('click', ()=> setTool('eraser'));
  textBtn.addEventListener('click', ()=> setTool('text'));

  colorInput.addEventListener('input', (e) => color = e.target.value);
  sizeInput.addEventListener('input', (e) => { size = Number(e.target.value); eraserCursor.style.width = size + 'px'; eraserCursor.style.height = size + 'px'; });
  opacityInput.addEventListener('input', (e) => opacity = Number(e.target.value));
  clearBtn.addEventListener('click', ()=> { if(confirm('Clear the entire board including text boxes?')) clearBoard(); });

  // Recording wiring
  recordBtn.addEventListener('click', ()=> { if(playback && playback.playing) { alert('Stop playback before recording.'); return; } startRecording(); });
  stopRecBtn.addEventListener('click', ()=> stopRecording());
  playBtn.addEventListener('click', ()=> { if(!recordingMemory){ alert('No recording loaded. Record or import first.'); return; } playRecording(); });
  pauseBtn.addEventListener('click', ()=> { /* not implemented: simple playback only */ alert('Pause/resume not available in this simplified build. Use Stop.'); });
  stopPlayBtn.addEventListener('click', ()=> stopPlayback());
  exportBtn.addEventListener('click', ()=> {
    if(!recordingMemory) return;
    const blob = new Blob([JSON.stringify(recordingMemory)], { type: 'application/json' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'whiteboard-recording.json';
    document.body.appendChild(a); a.click(); a.remove();
    URL.revokeObjectURL(a.href);
  });

  importFile.addEventListener('change', (ev) => {
    const f = ev.target.files[0];
    if(!f) return;
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const data = JSON.parse(e.target.result);
        if(data && Array.isArray(data.events)){
          recordingMemory = data;
          playBtn.disabled = false;
          exportBtn.disabled = false;
          status.textContent = `Imported ${data.events.length} events`;
        } else {
          alert('Invalid recording file.');
        }
      } catch(err) { alert('Failed to parse file: ' + err.message); }
    };
    reader.readAsText(f);
    ev.target.value = '';
  });
  importBtn.addEventListener('click', ()=> importFile.click());

  // Laser
  let laserActive = false;
  laserBtn.addEventListener('click', ()=> {
    laserActive = !laserActive;
    laserEl.style.display = laserActive ? 'block' : 'none';
    laserBtn.classList.toggle('active', laserActive);
    status.textContent = laserActive ? 'Laser on' : 'Laser off';
  });
  wrap.addEventListener('pointermove', (e)=> {
    if(laserActive){
      const r = wrap.getBoundingClientRect();
      laserEl.style.left = (e.clientX - r.left) + 'px';
      laserEl.style.top = (e.clientY - r.top) + 'px';
    }
  });

  // Keyboard shortcuts
  window.addEventListener('keydown', (e) => {
    if(e.key === 'p') setTool('pen');
    if(e.key === 'h') setTool('highlighter');
    if(e.key === 'e') setTool('eraser');
    if(e.key === 't') setTool('text');
    if((e.ctrlKey || e.metaKey) && e.key === 'r'){ e.preventDefault(); recordBtn.click(); }
    if((e.ctrlKey || e.metaKey) && e.key === 'p'){ e.preventDefault(); playBtn.click(); }
  });

  // Guide behavior: collapse/pin/remember state
  const GUIDE_KEY = 'whiteboard_guide_state_v1';
  function loadGuide(){ try{ const s = localStorage.getItem(GUIDE_KEY); return s ? JSON.parse(s) : { open:true, pinned:false, pos:null }; } catch(e){ return { open:true, pinned:false, pos:null }; } }
  function saveGuide(state){ try{ localStorage.setItem(GUIDE_KEY, JSON.stringify(state)); } catch(e){} }
  let guideState = loadGuide();
  function applyGuide(){
    if(!guideState.open){ guideEl.classList.add('collapsed'); toggleGuide.textContent = '+'; } else { guideEl.classList.remove('collapsed'); toggleGuide.textContent = '‚Äì'; }
    pinGuide.textContent = guideState.pinned ? 'üìå Pinned' : 'üìå Pin';
    if(guideState.pos && !guideState.pinned){
      guideEl.style.position = 'fixed';
      guideEl.style.left = guideState.pos.left;
      guideEl.style.top = guideState.pos.top;
      guideEl.style.bottom = '';
      guideEl.style.right = '';
    } else {
      guideEl.style.bottom = '12px';
      guideEl.style.right = '12px';
    }
  }
  applyGuide();
  toggleGuide.addEventListener('click', ()=> { guideState.open = !guideState.open; applyGuide(); saveGuide(guideState); });
  closeGuide.addEventListener('click', ()=> { guideEl.style.display = 'none'; guideState.open = false; saveGuide(guideState); });
  pinGuide.addEventListener('click', ()=> { guideState.pinned = !guideState.pinned; applyGuide(); saveGuide(guideState); });

  // allow dragging guide when not pinned
  let draggingGuide = false, dragStart = null, guideOrig = null;
  guideEl.addEventListener('pointerdown', (ev) => {
    const target = ev.target;
    if(guideState.pinned) return;
    if(target.closest('.controls') || target.closest('button')) return;
    draggingGuide = true;
    dragStart = { x: ev.clientX, y: ev.clientY };
    const rect = guideEl.getBoundingClientRect();
    guideOrig = { left: rect.left, top: rect.top };
    guideEl.style.transition = 'none';
  });
  window.addEventListener('pointermove', (ev) => {
    if(!draggingGuide) return;
    const dx = ev.clientX - dragStart.x, dy = ev.clientY - dragStart.y;
    const left = Math.min(window.innerWidth - 40, Math.max(8, guideOrig.left + dx));
    const top = Math.min(window.innerHeight - 40, Math.max(8, guideOrig.top + dy));
    guideEl.style.position = 'fixed';
    guideEl.style.left = left + 'px';
    guideEl.style.top = top + 'px';
    guideEl.style.bottom = '';
    guideEl.style.right = '';
  });
  window.addEventListener('pointerup', (ev) => {
    if(!draggingGuide) return;
    draggingGuide = false;
    guideEl.style.transition = '';
    guideState.pos = { left: guideEl.style.left, top: guideEl.style.top };
    saveGuide(guideState);
  });

  // initial UI states
  playBtn.disabled = true; pauseBtn.disabled = true; stopPlayBtn.disabled = true; exportBtn.disabled = true;
  ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,canvas.width,canvas.height);

})();
</script>
</body>
</html>
