<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Champak Roy ‚Äî Whiteboard (Text fix + Guide)</title>
<style>
  :root{--blue:#3f6bff;--bg:#eef3ff;--panel:#fff;--muted:#c7d6ff}
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;font-family:Arial,Helvetica,sans-serif;background:var(--bg)}
  .center{min-height:100vh;display:flex;align-items:center;justify-content:center;padding:14px}
  .board-container{width:95%;max-width:1200px;height:86vh;background:var(--panel);border:3px solid var(--blue);border-radius:12px;box-shadow:0 8px 30px rgba(0,0,0,0.08);position:relative;overflow:hidden;display:flex;flex-direction:column}
  .toolbar{display:flex;gap:8px;align-items:center;padding:10px}
  .tool-group{display:flex;gap:8px;align-items:center;padding:6px;border-radius:8px;background:rgba(255,255,255,0.95);border:1px solid var(--muted)}
  button, input[type=range], input[type=color]{font-size:13px;padding:6px 8px;border-radius:6px;border:1px solid #e6eefc;cursor:pointer;background:#fbfdff}
  button.small{padding:6px}
  button.active{background:rgba(63,107,255,0.12);color:var(--blue)}
  .spacer{flex:1}
  .canvas-wrap{position:relative;flex:1;display:block;background:#fff}
  canvas#board{position:absolute;left:0;top:0;width:100%;height:100%;touch-action:none;display:block}
  .text-note{position:absolute;min-width:120px;min-height:28px;padding:6px 8px;border-radius:6px;border:1px dashed rgba(0,0,0,0.12);background:rgba(255,255,255,0.96);resize:both;overflow:auto;font-size:16px}
  .laser{position:absolute;pointer-events:none;border-radius:50%;width:28px;height:28px;margin-left:-14px;margin-top:-14px;box-shadow:0 0 12px rgba(255,0,0,0.45);display:none;z-index:120}
  .playbackProgress{width:160px;height:8px;background:rgba(0,0,0,0.06);border-radius:6px;overflow:hidden}
  .playbackBar{height:100%;width:0;background:linear-gradient(90deg,var(--blue),#7cc0ff)}
  .controls {display:flex;gap:6px;align-items:center}
  .fileInput{display:none}
  .status{font-size:13px;color:#333;padding-left:8px}
  @media(max-width:760px){.desktop-only{display:none}}

  /* GUIDE (top-right) */
  .guide {
    position: absolute;
    top: 12px;
    right: 12px;
    width: 320px;
    max-width: calc(100% - 28px);
    background: linear-gradient(180deg, rgba(255,255,255,0.98), rgba(248,249,255,0.98));
    border: 1px solid rgba(99,123,255,0.12);
    box-shadow: 0 10px 30px rgba(31,41,55,0.08);
    border-radius: 10px;
    z-index: 200;
    overflow: hidden;
    font-size: 13px;
  }
  .guide .head {
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:8px;
    padding:8px 10px;
    background: rgba(255,255,255,0.9);
    border-bottom:1px solid rgba(0,0,0,0.03);
  }
  .guide .title { font-weight:600; color:#14213d; }
  .guide .controls { display:flex; gap:8px; align-items:center; }
  .guide .btn {
    background:transparent; border:1px solid rgba(0,0,0,0.06); padding:6px 8px; border-radius:6px; cursor:pointer;
  }
  .guide .btn.small { padding:4px 6px; font-size:12px }
  .guide .content {
    padding:10px;
    line-height:1.4;
    color:#222;
    max-height: 360px;
    overflow:auto;
  }
  .guide h4 { margin:6px 0 6px 0; font-size:14px; }
  .guide ol, .guide ul { margin:6px 0 10px 18px; padding:0; }
  .guide .shortcut { display:inline-block; background:#f1f7ff; border:1px solid #e6efff; padding:2px 6px; border-radius:6px; font-weight:600; margin-right:6px; font-size:12px; }
  .guide .footer { padding:8px 10px; border-top:1px solid rgba(0,0,0,0.03); background: rgba(255,255,255,0.96); display:flex; justify-content:space-between; align-items:center; gap:8px; }
  .guide .pin { cursor:pointer; font-size:12px; padding:6px; border-radius:6px; background:transparent; border:1px solid rgba(0,0,0,0.04) }
  .guide.collapsed { width:44px; height:44px; border-radius:50%; overflow:visible; padding:0; right:12px; top:12px; }
  .guide.collapsed .head { display:flex; justify-content:center; align-items:center; padding:0; border-bottom:none; }
  .guide.collapsed .content, .guide.collapsed .footer { display:none; }
  .guide .help-title { font-size:13px; color:#0b2545; }
</style>
</head>
<body>

<div class="center">
  <div class="board-container" id="boardContainer">

    <div class="toolbar" role="toolbar" aria-label="Whiteboard toolbar">
      <div class="tool-group" id="mainTools">
        <button id="penBtn" class="active" title="Pen">‚úè Pen</button>
        <button id="highlighterBtn" title="Highlighter">üñç Hl</button>
        <button id="eraserBtn" title="Eraser">üßΩ Erase</button>
        <button id="textBtn" title="Text">T</button>

        <label>Color</label><input type="color" id="color" value="#000000">
        <label>Size</label><input type="range" id="size" min="1" max="60" value="4">
        <label>Opacity</label><input type="range" id="opacity" min="0.1" max="1" step="0.05" value="1">
      </div>

      <div class="spacer"></div>

      <div class="tool-group">
        <div class="controls">
          <button id="recordBtn" class="small" title="Start recording">‚óè Record</button>
          <button id="stopRecBtn" class="small" title="Stop recording" disabled>‚ñ† Stop</button>

          <button id="playBtn" class="small" title="Play" disabled>‚ñ∂ Play</button>
          <button id="pauseBtn" class="small" title="Pause" disabled>‚è∏ Pause</button>
          <button id="stopPlayBtn" class="small" title="Stop playback" disabled>‚ñ† Stop</button>

          <button id="laserBtn" class="small" title="Toggle laser pointer">üî¥ Laser</button>

          <button id="exportBtn" class="small" title="Export recording" disabled>‚¨á Export</button>
          <label for="importFile" style="padding:0;margin:0"><button id="importBtn" class="small" title="Import recording">‚¨Ü Import</button></label>
          <input type="file" id="importFile" class="fileInput" accept=".json">
        </div>
        <div style="padding-left:8px;display:flex;align-items:center;gap:8px">
          <div class="playbackProgress" title="Playback progress"><div id="playbar" class="playbackBar"></div></div>
          <div class="status" id="status">Ready</div>
        </div>
      </div>
    </div>

    <div class="canvas-wrap" id="canvasWrap">
      <canvas id="board"></canvas>
      <div id="laser" class="laser" style="background: rgba(255,0,0,0.55); display:none"></div>
    </div>

    <!-- How to use guide (top-right) -->
    <div id="howto" class="guide" role="region" aria-label="How to use whiteboard guide">
      <div class="head">
        <div>
          <div class="title help-title">How to use ‚Äî Whiteboard</div>
          <div style="font-size:11px;color:#445;opacity:0.9">Quick guide</div>
        </div>
        <div class="controls">
          <button id="toggleGuide" class="btn small" title="Collapse/expand guide">‚Äì</button>
          <button id="closeGuide" class="btn small" title="Hide guide temporarily">‚úï</button>
        </div>
      </div>

      <div class="content" id="guideContent">
        <h4>Basic steps</h4>
        <ol>
          <li>Select a tool: <strong>Pen</strong>, <strong>Highlighter</strong>, <strong>Eraser</strong>, or <strong>Text</strong>.</li>
          <li>Pick <span class="shortcut">Color</span>, adjust <span class="shortcut">Size</span> and <span class="shortcut">Opacity</span> as needed.</li>
          <li>Draw on the board using mouse, touch, or pen. Use the <strong>Text</strong> tool to click and add editable text boxes.</li>
        </ol>

        <h4>Recording & playback</h4>
        <ul>
          <li>Click <strong>Record</strong> to start recording your strokes. Click <strong>Stop</strong> to finish.</li>
          <li>Use <strong>Play</strong> to replay the recorded session, <strong>Pause</strong> to pause, and <strong>Stop</strong> to end playback.</li>
          <li><strong>Export</strong> saves the recording as JSON. Use <strong>Import</strong> to load a saved recording.</li>
        </ul>

        <h4>Laser pointer</h4>
        <ul>
          <li>Toggle <strong>Laser</strong> to get a non-destructive red pointer that follows your cursor or finger while explaining live.</li>
          <li>Laser does NOT draw on the board ‚Äî it‚Äôs only for presentation.</li>
        </ul>

        <h4>Tips</h4>
        <ul>
          <li>Text boxes are editable and draggable (double-click to delete a box).</li>
          <li>Recording saves pen/highlighter/eraser strokes and timing ‚Äî text boxes are not recorded in this version.</li>
          <li>Use <span class="shortcut">Ctrl/Cmd + R</span> to start recording and <span class="shortcut">Ctrl/Cmd + P</span> to play.</li>
        </ul>

        <h4>Keyboard shortcuts</h4>
        <ul>
          <li><span class="shortcut">P</span> ‚Äî Pen</li>
          <li><span class="shortcut">H</span> ‚Äî Highlighter</li>
          <li><span class="shortcut">E</span> ‚Äî Eraser</li>
          <li><span class="shortcut">T</span> ‚Äî Text</li>
          <li><span class="shortcut">Ctrl/Cmd + R</span> ‚Äî Start recording</li>
          <li><span class="shortcut">Ctrl/Cmd + P</span> ‚Äî Play</li>
        </ul>
      </div>

      <div class="footer">
        <div style="font-size:12px;color:#445">Guide</div>
        <div>
          <button id="pinGuide" class="pin" title="Pin guide (remember state)">üìå Pin</button>
        </div>
      </div>
    </div>

  </div>
</div>

<script>
/* Fixed Text tool + existing features (record/play/laser/guide)
   Key changes:
   - When tool === 'text' a movable/resizable contentEditable DIV is created at the click position.
   - Text notes are preserved on saveSnapshot and not disturbed by playback (playback draws on canvas).
   - Double-click deletes a text note.
*/

(() => {
  // --- Canvas setup ---
  const canvas = document.getElementById('board');
  const wrap = document.getElementById('canvasWrap');
  const ctx = canvas.getContext('2d', {alpha:false}); // opaque white background
  function resizeCanvas(){
    const r = wrap.getBoundingClientRect();
    const tmp = document.createElement('canvas');
    tmp.width = canvas.width || Math.max(800, Math.floor(r.width));
    tmp.height = canvas.height || Math.max(400, Math.floor(r.height));
    const tctx = tmp.getContext('2d');
    if(canvas.width && canvas.height) tctx.drawImage(canvas,0,0);

    canvas.width = Math.floor(r.width);
    canvas.height = Math.floor(r.height);
    // white background
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.drawImage(tmp,0,0, tmp.width, tmp.height, 0,0, canvas.width, canvas.height);
  }
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);

  // --- Controls ---
  const penBtn = document.getElementById('penBtn'), highlighterBtn = document.getElementById('highlighterBtn'),
        eraserBtn = document.getElementById('eraserBtn'), textBtn = document.getElementById('textBtn');
  const colorInput = document.getElementById('color'), sizeInput = document.getElementById('size'), opacityInput = document.getElementById('opacity');

  const recordBtn = document.getElementById('recordBtn'), stopRecBtn = document.getElementById('stopRecBtn');
  const playBtn = document.getElementById('playBtn'), pauseBtn = document.getElementById('pauseBtn'), stopPlayBtn = document.getElementById('stopPlayBtn');
  const exportBtn = document.getElementById('exportBtn'), importFile = document.getElementById('importFile'), importBtn = document.getElementById('importBtn');
  const laserBtn = document.getElementById('laserBtn'), laserEl = document.getElementById('laser');
  const playbar = document.getElementById('playbar'), status = document.getElementById('status');

  // --- Drawing state ---
  let tool = 'pen';
  let color = colorInput.value, size = Number(sizeInput.value), opacity = Number(opacityInput.value);
  let drawing = false;
  let points = [];
  let lastPointerId = null;

  // snapshot stack for undo/redo (small)
  let snapshots = [], snapIdx = -1;
  function saveSnapshot(){
    try{
      const data = canvas.toDataURL('image/png');
      snapshots = snapshots.slice(0, snapIdx+1);
      snapshots.push(data);
      if(snapshots.length>20) snapshots.shift();
      snapIdx = snapshots.length-1;
    }catch(e){/*ignore*/}
  }
  function restoreSnapshot(i){
    if(i<0 || i>=snapshots.length) return;
    const img = new Image();
    img.onload = ()=> { ctx.clearRect(0,0,canvas.width,canvas.height); ctx.drawImage(img,0,0,canvas.width,canvas.height); };
    img.src = snapshots[i];
  }
  saveSnapshot(); // initial

  // --- Recording ---
  let recording = null; // active recording while recording
  let recordingMemory = null; // saved recording (for playback/import/export)
  let isRecording = false;
  let recordStartTime = 0;

  // playback state
  let playback = null;

  const currentMs = () => performance.now();

  function startRecording(){
    recording = { events: [], duration:0 };
    isRecording = true;
    recordStartTime = currentMs();
    recordBtn.disabled = true;
    stopRecBtn.disabled = false;
    playBtn.disabled = true;
    exportBtn.disabled = true;
    status.textContent = 'Recording...';
  }

  function stopRecording(){
    if(!isRecording) return;
    isRecording = false;
    recording.duration = Math.max(0, currentMs() - recordStartTime);
    recordingMemory = recording;
    recordBtn.disabled = false;
    stopRecBtn.disabled = true;
    playBtn.disabled = recordingMemory.events.length > 0 ? false : true;
    exportBtn.disabled = recordingMemory.events.length > 0 ? false : true;
    status.textContent = `Recorded ${Math.round(recording.duration)} ms`;
  }

  function pushEvent(ev){
    if(!isRecording || !recording) return;
    const t = Math.round(currentMs() - recordStartTime);
    recording.events.push(Object.assign({ t }, ev));
  }

  // drawing helpers
  function applyStrokeSettings(ctxLocal, evTool, evColor, evSize, evOpacity){
    if(evTool === 'eraser'){
      ctxLocal.globalCompositeOperation = 'destination-out';
      ctxLocal.globalAlpha = 1;
      ctxLocal.strokeStyle = 'rgba(0,0,0,1)';
    } else {
      ctxLocal.globalCompositeOperation = 'source-over';
      ctxLocal.globalAlpha = evOpacity;
      ctxLocal.strokeStyle = evColor;
    }
    ctxLocal.lineCap = 'round';
    ctxLocal.lineJoin = 'round';
    ctxLocal.lineWidth = evSize;
  }

  function drawSegment(prev, curr, evTool, evColor, evSize, evOpacity){
    applyStrokeSettings(ctx, evTool, evColor, evSize, evOpacity);
    ctx.beginPath();
    ctx.moveTo(prev.x, prev.y);
    ctx.lineTo(curr.x, curr.y);
    ctx.stroke();
  }

  // --- Text note helper (working) ---
  function addTextNoteAt(x, y, html = '', w = 180, h = 40, styles = null){
    const note = document.createElement('div');
    note.className = 'text-note';
    note.contentEditable = true;
    note.innerHTML = html || '';
    note.style.left = (x)+'px';
    note.style.top = (y)+'px';
    note.style.width = (w || 160) + 'px';
    note.style.height = (h || 36) + 'px';
    note.style.zIndex = 110;
    if(styles){
      if(styles.fontSize) note.style.fontSize = styles.fontSize;
      if(styles.color) note.style.color = styles.color;
    }
    // focus and add behavior
    note.addEventListener('blur', () => { saveSnapshot(); });
    // dragging
    let dragging = false, start = null, orig = null;
    note.addEventListener('pointerdown', (ev) => {
      // if resizing (browser shows resize handle) pointerdown may be on resize; let that through
      if(ev.button && ev.button !== 0) return;
      ev.stopPropagation();
      dragging = true;
      start = {x:ev.clientX, y:ev.clientY};
      const r = note.getBoundingClientRect();
      const parentRect = wrap.getBoundingClientRect();
      orig = {left: r.left - parentRect.left, top: r.top - parentRect.top};
      note.style.touchAction = 'none';
      note.setPointerCapture && note.setPointerCapture(ev.pointerId);
    });
    window.addEventListener('pointermove', (ev) => {
      if(!dragging) return;
      const dx = ev.clientX - start.x;
      const dy = ev.clientY - start.y;
      note.style.left = (orig.left + dx) + 'px';
      note.style.top = (orig.top + dy) + 'px';
    });
    window.addEventListener('pointerup', (ev) => {
      if(!dragging) return;
      dragging = false;
      note.style.touchAction = '';
      note.releasePointerCapture && note.releasePointerCapture(ev.pointerId);
      saveSnapshot();
    });
    // double-click to delete
    note.addEventListener('dblclick', (ev) => {
      if(confirm('Delete this text box?')) { note.remove(); saveSnapshot(); }
    });
    wrap.appendChild(note);
    // focus for immediate typing
    setTimeout(()=> note.focus(), 10);
    return note;
  }

  // pointer events (with text handling)
  canvas.addEventListener('pointerdown', (e)=>{
    // if text tool ‚Äî create a text note and do not begin drawing
    if(tool === 'text'){
      const rp = wrap.getBoundingClientRect();
      const x = e.clientX - rp.left;
      const y = e.clientY - rp.top;
      addTextNoteAt(x, y, '', 220, 36, { fontSize: '16px', color: color });
      // stop propagation to avoid any drawing behavior
      e.preventDefault();
      return;
    }

    // normal drawing tools
    if(e.button && e.button !== 0) return;
    canvas.setPointerCapture && canvas.setPointerCapture(e.pointerId);
    drawing = true;
    lastPointerId = e.pointerId;
    const pos = getPos(e);
    points = [pos];
    pushEvent({ type:'start', tool, color, size, opacity, x:pos.x, y:pos.y });
    applyStrokeSettings(ctx, tool, color, size, opacity);
    ctx.beginPath();
    ctx.moveTo(pos.x, pos.y);
    ctx.lineTo(pos.x+0.01, pos.y+0.01);
    ctx.stroke();
    e.preventDefault();
  }, {passive:false});

  canvas.addEventListener('pointermove', (e)=>{
    if(!drawing || e.pointerId !== lastPointerId) return;
    const pos = getPos(e);
    const prev = points[points.length-1];
    points.push(pos);
    drawSegment(prev, pos, tool, color, size, opacity);
    pushEvent({ type:'move', x:pos.x, y:pos.y });
    e.preventDefault();
    if(laserActive) positionLaser(e.clientX, e.clientY);
  }, {passive:false});

  window.addEventListener('pointerup', (e)=>{
    if(drawing && e.pointerId === lastPointerId){
      drawing = false;
      canvas.releasePointerCapture && canvas.releasePointerCapture(e.pointerId);
      const pos = points[points.length-1] || getPos(e);
      pushEvent({ type:'end', x:pos.x, y:pos.y });
      saveSnapshot();
    }
  }, {passive:false});

  function getPos(e){
    const r = canvas.getBoundingClientRect();
    return { x: e.clientX - r.left, y: e.clientY - r.top };
  }

  // tool UI
  function setTool(t){
    tool = t;
    [penBtn, highlighterBtn, eraserBtn, textBtn].forEach(b => b.classList.remove('active'));
    if(t==='pen') penBtn.classList.add('active');
    if(t==='highlighter') highlighterBtn.classList.add('active');
    if(t==='eraser') eraserBtn.classList.add('active');
    if(t==='text') textBtn.classList.add('active');
    canvas.style.cursor = (t==='text' ? 'text' : 'crosshair');
  }
  penBtn.addEventListener('click', ()=> setTool('pen'));
  highlighterBtn.addEventListener('click', ()=> setTool('highlighter'));
  eraserBtn.addEventListener('click', ()=> setTool('eraser'));
  textBtn.addEventListener('click', ()=> setTool('text'));

  colorInput.addEventListener('input', (e)=> { color = e.target.value; });
  sizeInput.addEventListener('input', (e)=> { size = Number(e.target.value); });
  opacityInput.addEventListener('input', (e)=> { opacity = Number(e.target.value); });

  // recording controls
  recordBtn.addEventListener('click', ()=> {
    if(playback && playback.playing) { alert('Stop playback before recording.'); return; }
    startRecording();
  });
  stopRecBtn.addEventListener('click', ()=> stopRecording());

  exportBtn.addEventListener('click', ()=>{
    if(!recordingMemory) return;
    const blob = new Blob([JSON.stringify(recordingMemory)], {type:'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = 'whiteboard-recording.json';
    document.body.appendChild(a); a.click(); a.remove();
    URL.revokeObjectURL(url);
  });

  importFile.addEventListener('change', (ev)=> {
    const f = ev.target.files[0];
    if(!f) return;
    const reader = new FileReader();
    reader.onload = (e) => {
      try{
        const data = JSON.parse(e.target.result);
        if(data && Array.isArray(data.events)){
          stopPlayback();
          isRecording = false; recording = null;
          recordingMemory = data;
          status.textContent = `Imported ${data.events.length} events (${Math.round(data.duration||0)} ms)`;
          playBtn.disabled = false; exportBtn.disabled = false;
        } else alert('Invalid recording file.');
      }catch(err){ alert('Failed to parse file: ' + err.message); }
    };
    reader.readAsText(f);
    ev.target.value = '';
  });
  importBtn.addEventListener('click', ()=> importFile.click());

  // --- Recording implementation (as before) ---
  function startRecording(){
    recording = { events: [], duration:0 };
    isRecording = true;
    recordStartTime = currentMs();
    recordBtn.disabled = true;
    stopRecBtn.disabled = false;
    playBtn.disabled = true;
    exportBtn.disabled = true;
    status.textContent = 'Recording...';
  }

  function stopRecording(){
    if(!isRecording) return;
    isRecording = false;
    recording.duration = Math.max(0, currentMs() - recordStartTime);
    recordingMemory = recording;
    recordBtn.disabled = false;
    stopRecBtn.disabled = true;
    playBtn.disabled = recordingMemory.events.length > 0 ? false : true;
    exportBtn.disabled = recordingMemory.events.length > 0 ? false : true;
    status.textContent = `Recorded ${Math.round(recording.duration)} ms`;
  }

  function pushEvent(ev){
    if(!isRecording || !recording) return;
    const t = Math.round(currentMs() - recordStartTime);
    recording.events.push(Object.assign({ t }, ev));
  }

  // playback (same approach)
  function playRecording(){
    if(!recordingMemory || !recordingMemory.events || recordingMemory.events.length===0) return;
    stopPlayback();
    playback = { script: recordingMemory, startTime: currentMs(), playing: true, timerIds: [] };
    setPlaybackUI(true);
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,canvas.width,canvas.height);

    const evs = recordingMemory.events;
    let penState = null;
    for(let i=0;i<evs.length;i++){
      const ev = evs[i];
      const id = setTimeout(() => {
        if(!playback || !playback.playing) return;
        if(ev.type === 'start'){
          penState = { x: ev.x, y: ev.y, tool: ev.tool, color: ev.color, size: ev.size, opacity: ev.opacity };
          applyStrokeSettings(ctx, penState.tool, penState.color, penState.size, penState.opacity);
          ctx.beginPath(); ctx.moveTo(penState.x, penState.y); ctx.lineTo(penState.x+0.01, penState.y+0.01); ctx.stroke();
        } else if(ev.type === 'move'){
          if(!penState) return;
          const prev = { x: penState.x, y: penState.y };
          const curr = { x: ev.x, y: ev.y };
          drawSegment(prev, curr, penState.tool, penState.color, penState.size, penState.opacity);
          penState.x = curr.x; penState.y = curr.y;
        } else if(ev.type === 'end'){
          penState = null;
        }
        const progress = Math.min(1, (currentMs() - playback.startTime) / (playback.script.duration || 1));
        playbar.style.width = (progress*100)+'%';
        if(progress >= 1){
          setTimeout(() => { stopPlayback(); status.textContent = 'Playback finished'; }, 20);
        }
      }, ev.t);
      playback.timerIds.push(id);
    }
    status.textContent = 'Playing...';
  }

  function pausePlayback(){
    if(!playback || !playback.playing) return;
    playback.pausedAt = currentMs() - playback.startTime;
    playback.playing = false;
    playback.timerIds.forEach(id => clearTimeout(id));
    playback.timerIds = [];
    setPlaybackUI(false, true);
    status.textContent = 'Paused';
  }

  function resumePlayback(){
    if(!playback || playback.playing) return;
    const script = playback.script;
    const pausedAt = playback.pausedAt || 0;
    playback.startTime = currentMs() - pausedAt;
    playback.playing = true;
    playback.timerIds = [];
    for(let ev of script.events){
      const when = ev.t - pausedAt;
      if(when <= 0) continue;
      const id = setTimeout(() => {
        if(!playback || !playback.playing) return;
        if(ev.type === 'start'){
          applyStrokeSettings(ctx, ev.tool, ev.color, ev.size, ev.opacity);
          ctx.beginPath(); ctx.moveTo(ev.x, ev.y); ctx.lineTo(ev.x+0.01, ev.y+0.01); ctx.stroke();
        } else if(ev.type === 'move'){
          applyStrokeSettings(ctx, ev.tool, ev.color, ev.size, ev.opacity);
          ctx.beginPath(); ctx.moveTo(ev.x-0.5, ev.y-0.5); ctx.lineTo(ev.x, ev.y); ctx.stroke();
        }
        const progress = Math.min(1, (currentMs() - playback.startTime) / (playback.script.duration || 1));
        playbar.style.width = (progress*100)+'%';
        if(progress >= 1){
          setTimeout(() => { stopPlayback(); status.textContent = 'Playback finished'; }, 20);
        }
      }, when);
      playback.timerIds.push(id);
    }
    setPlaybackUI(true);
    status.textContent = 'Playing...';
  }

  function stopPlayback(){
    if(!playback){
      playbar.style.width = '0%';
      playBtn.disabled = recordingMemory ? false : true;
      pauseBtn.disabled = true;
      stopPlayBtn.disabled = true;
      return;
    }
    playback.timerIds.forEach(id => clearTimeout(id));
    playback = null;
    playbar.style.width = '0%';
    setPlaybackUI(false);
    status.textContent = 'Ready';
    saveSnapshot();
  }

  function setPlaybackUI(isPlaying, isPaused=false){
    playBtn.disabled = isPlaying;
    pauseBtn.disabled = !isPlaying && !isPaused;
    stopPlayBtn.disabled = !isPlaying && !isPaused;
    const disabled = !!isPlaying || isPaused;
    penBtn.disabled = disabled; highlighterBtn.disabled = disabled; eraserBtn.disabled = disabled; textBtn.disabled = disabled;
    colorInput.disabled = disabled; sizeInput.disabled = disabled; opacityInput.disabled = disabled;
  }

  playBtn.addEventListener('click', ()=> { if(!recordingMemory) { alert('No recording loaded. Record or import first.'); return; } playRecording(); });
  pauseBtn.addEventListener('click', ()=> { if(playback && playback.playing) pausePlayback(); else if(playback && !playback.playing) resumePlayback(); });
  stopPlayBtn.addEventListener('click', ()=> stopPlayback());

  // laser pointer
  let laserActive = false;
  laserBtn.addEventListener('click', ()=>{
    laserActive = !laserActive;
    laserEl.style.display = laserActive ? 'block' : 'none';
    laserBtn.classList.toggle('active', laserActive);
    status.textContent = laserActive ? 'Laser on' : 'Laser off';
  });
  function positionLaser(clientX, clientY){
    const r = wrap.getBoundingClientRect();
    laserEl.style.left = (clientX - r.left) + 'px';
    laserEl.style.top = (clientY - r.top) + 'px';
  }
  wrap.addEventListener('pointermove', (e)=> { if(laserActive) positionLaser(e.clientX, e.clientY); });

  // keyboard shortcuts
  window.addEventListener('keydown', (e)=>{
    if(e.key === 'p') setTool('pen');
    if(e.key === 'h') setTool('highlighter');
    if(e.key === 'e') setTool('eraser');
    if(e.key === 't') setTool('text');
    if((e.ctrlKey || e.metaKey) && e.key === 'r'){ e.preventDefault(); recordBtn.click(); }
    if((e.ctrlKey || e.metaKey) && e.key === 'p'){ e.preventDefault(); playBtn.click(); }
  });

  // initial UI state
  playBtn.disabled = true; pauseBtn.disabled = true; stopPlayBtn.disabled = true; exportBtn.disabled = true;

  ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,canvas.width,canvas.height);

  // -----------------------
  // GUIDE: collapse/close/pin behavior
  // -----------------------
  const GUIDE_KEY = 'whiteboard_guide_state_v1';
  const guideEl = document.getElementById('howto');
  const toggleBtn = document.getElementById('toggleGuide');
  const closeBtn = document.getElementById('closeGuide');
  const pinBtn = document.getElementById('pinGuide');

  function loadGuideState(){
    try{
      const raw = localStorage.getItem(GUIDE_KEY);
      if(!raw) return { open:true, pinned:false };
      return JSON.parse(raw);
    }catch(e){ return { open:true, pinned:false }; }
  }
  function saveGuideState(state){
    try{ localStorage.setItem(GUIDE_KEY, JSON.stringify(state)); }catch(e){}
  }
  let guideState = loadGuideState();
  function applyGuideState(){
    if(!guideState.open) {
      guideEl.classList.add('collapsed');
      toggleBtn.textContent = '+';
    } else {
      guideEl.classList.remove('collapsed');
      toggleBtn.textContent = '‚Äì';
    }
    pinBtn.textContent = guideState.pinned ? 'üìå Pinned' : 'üìå Pin';
  }
  applyGuideState();

  toggleBtn.addEventListener('click', ()=>{
    guideState.open = !guideState.open;
    applyGuideState();
    saveGuideState(guideState);
  });

  closeBtn.addEventListener('click', ()=>{
    guideEl.style.display = 'none';
    guideState.open = false;
    saveGuideState(guideState);
  });

  pinBtn.addEventListener('click', ()=>{
    guideState.pinned = !guideState.pinned;
    applyGuideState();
    saveGuideState(guideState);
  });

  // allow dragging guide when not pinned
  let draggingGuide = false, dragStart = null, guideOrig = null;
  guideEl.addEventListener('pointerdown', (e)=>{
    const target = e.target;
    if(guideState.pinned) return;
    if(target.closest('.controls') || target.closest('.btn') || target.closest('.pin')) return;
    draggingGuide = true;
    dragStart = { x: e.clientX, y: e.clientY };
    const rect = guideEl.getBoundingClientRect();
    guideOrig = { left: rect.left, top: rect.top };
    guideEl.style.transition = 'none';
    guideEl.setPointerCapture && guideEl.setPointerCapture(e.pointerId);
  });

  window.addEventListener('pointermove', (e)=>{
    if(!draggingGuide) return;
    const dx = e.clientX - dragStart.x;
    const dy = e.clientY - dragStart.y;
    const left = Math.min(window.innerWidth - 40, Math.max(8, guideOrig.left + dx));
    const top = Math.min(window.innerHeight - 40, Math.max(8, guideOrig.top + dy));
    guideEl.style.position = 'fixed';
    guideEl.style.left = left + 'px';
    guideEl.style.top = top + 'px';
  });

  window.addEventListener('pointerup', (e)=>{
    if(!draggingGuide) return;
    draggingGuide = false;
    guideEl.releasePointerCapture && guideEl.releasePointerCapture(e.pointerId);
    guideEl.style.transition = '';
    guideState.pos = { left: guideEl.style.left, top: guideEl.style.top };
    saveGuideState(guideState);
  });

})();
</script>
</body>
</html>
