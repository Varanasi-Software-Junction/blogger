<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Champak Roy ‚Äî Whiteboard with Recording & Laser Pointer</title>
<style>
  :root{--blue:#3f6bff;--bg:#eef3ff;--panel:#fff;--muted:#c7d6ff}
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;font-family:Arial,Helvetica,sans-serif;background:var(--bg)}
  .center{min-height:100vh;display:flex;align-items:center;justify-content:center;padding:14px}
  .board-container{width:95%;max-width:1200px;height:86vh;background:var(--panel);border:3px solid var(--blue);border-radius:12px;box-shadow:0 8px 30px rgba(0,0,0,0.08);position:relative;overflow:hidden;display:flex;flex-direction:column}
  .toolbar{display:flex;gap:8px;align-items:center;padding:10px}
  .tool-group{display:flex;gap:8px;align-items:center;padding:6px;border-radius:8px;background:rgba(255,255,255,0.95);border:1px solid var(--muted)}
  button, input[type=range], input[type=color]{font-size:13px;padding:6px 8px;border-radius:6px;border:1px solid #e6eefc;cursor:pointer;background:#fbfdff}
  button.small{padding:6px}
  button.active{background:rgba(63,107,255,0.12);color:var(--blue)}
  .spacer{flex:1}
  .canvas-wrap{position:relative;flex:1;display:block;background:#fff}
  canvas#board{position:absolute;left:0;top:0;width:100%;height:100%;touch-action:none;display:block}
  .text-note{position:absolute;min-width:120px;min-height:28px;padding:6px 8px;border-radius:6px;border:1px dashed rgba(0,0,0,0.12);background:rgba(255,255,255,0.96);resize:both;overflow:auto}
  .laser{position:absolute;pointer-events:none;border-radius:50%;width:28px;height:28px;margin-left:-14px;margin-top:-14px;box-shadow:0 0 12px rgba(255,0,0,0.45);display:none;z-index:120}
  .playbackProgress{width:160px;height:8px;background:rgba(0,0,0,0.06);border-radius:6px;overflow:hidden}
  .playbackBar{height:100%;width:0;background:linear-gradient(90deg,var(--blue),#7cc0ff)}
  .controls {display:flex;gap:6px;align-items:center}
  .fileInput{display:none}
  .status{font-size:13px;color:#333;padding-left:8px}
  @media(max-width:760px){.desktop-only{display:none}}
</style>
</head>
<body>
<div class="center">
  <div class="board-container" id="boardContainer">

    <div class="toolbar" role="toolbar" aria-label="Whiteboard toolbar">
      <div class="tool-group" id="mainTools">
        <button id="penBtn" class="active" title="Pen">‚úè Pen</button>
        <button id="highlighterBtn" title="Highlighter">üñç Hl</button>
        <button id="eraserBtn" title="Eraser">üßΩ Erase</button>
        <button id="textBtn" title="Text">T</button>

        <label>Color</label><input type="color" id="color" value="#000000">
        <label>Size</label><input type="range" id="size" min="1" max="60" value="4">
        <label>Opacity</label><input type="range" id="opacity" min="0.1" max="1" step="0.05" value="1">
      </div>

      <div class="spacer"></div>

      <div class="tool-group">
        <div class="controls">
          <!-- Recording controls -->
          <button id="recordBtn" class="small" title="Start recording">‚óè Record</button>
          <button id="stopRecBtn" class="small" title="Stop recording" disabled>‚ñ† Stop</button>

          <button id="playBtn" class="small" title="Play" disabled>‚ñ∂ Play</button>
          <button id="pauseBtn" class="small" title="Pause" disabled>‚è∏ Pause</button>
          <button id="stopPlayBtn" class="small" title="Stop playback" disabled>‚ñ† Stop</button>

          <button id="laserBtn" class="small" title="Toggle laser pointer">üî¥ Laser</button>

          <button id="exportBtn" class="small" title="Export recording" disabled>‚¨á Export</button>
          <label for="importFile" style="padding:0;margin:0"><button id="importBtn" class="small" title="Import recording">‚¨Ü Import</button></label>
          <input type="file" id="importFile" class="fileInput" accept=".json">
        </div>
        <div style="padding-left:8px;display:flex;align-items:center;gap:8px">
          <div class="playbackProgress" title="Playback progress"><div id="playbar" class="playbackBar"></div></div>
          <div class="status" id="status">Ready</div>
        </div>
      </div>
    </div>

    <div class="canvas-wrap" id="canvasWrap">
      <canvas id="board"></canvas>
      <div id="laser" class="laser" style="background: rgba(255,0,0,0.55); display:none"></div>
    </div>

  </div>
</div>

<script>
/* Whiteboard with recording & laser pointer
   - Uses pointer events
   - Records stroke events (start, move, end) with timestamps (ms) relative to record start
   - Playback replays strokes preserving timing
   - Laser pointer shows a temporary overlay that follows pointer (non-destructive)
*/

(() => {
  // --- Canvas setup ---
  const canvas = document.getElementById('board');
  const wrap = document.getElementById('canvasWrap');
  const ctx = canvas.getContext('2d', {alpha:false}); // opaque white background
  function resizeCanvas(){
    const r = wrap.getBoundingClientRect();
    // preserve image
    const tmp = document.createElement('canvas');
    tmp.width = canvas.width || Math.max(800, Math.floor(r.width));
    tmp.height = canvas.height || Math.max(400, Math.floor(r.height));
    const tctx = tmp.getContext('2d');
    if(canvas.width && canvas.height) tctx.drawImage(canvas,0,0);

    canvas.width = Math.floor(r.width);
    canvas.height = Math.floor(r.height);
    // white background
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.drawImage(tmp,0,0, tmp.width, tmp.height, 0,0, canvas.width, canvas.height);
  }
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);

  // --- Controls ---
  const penBtn = document.getElementById('penBtn'), highlighterBtn = document.getElementById('highlighterBtn'),
        eraserBtn = document.getElementById('eraserBtn'), textBtn = document.getElementById('textBtn');
  const colorInput = document.getElementById('color'), sizeInput = document.getElementById('size'), opacityInput = document.getElementById('opacity');

  // Recording UI
  const recordBtn = document.getElementById('recordBtn'), stopRecBtn = document.getElementById('stopRecBtn');
  const playBtn = document.getElementById('playBtn'), pauseBtn = document.getElementById('pauseBtn'), stopPlayBtn = document.getElementById('stopPlayBtn');
  const exportBtn = document.getElementById('exportBtn'), importFile = document.getElementById('importFile'), importBtn = document.getElementById('importBtn');
  const laserBtn = document.getElementById('laserBtn'), laserEl = document.getElementById('laser');
  const playbar = document.getElementById('playbar'), status = document.getElementById('status');

  // --- Drawing state ---
  let tool = 'pen';
  let color = colorInput.value, size = Number(sizeInput.value), opacity = Number(opacityInput.value);
  let drawing = false;
  let points = []; // current stroke points
  let lastPointerId = null;

  // snapshot stack for undo/redo (optional small)
  let snapshots = [], snapIdx = -1;
  function saveSnapshot(){
    try{
      const data = canvas.toDataURL('image/png');
      snapshots = snapshots.slice(0, snapIdx+1);
      snapshots.push(data);
      if(snapshots.length>20) snapshots.shift();
      snapIdx = snapshots.length-1;
    }catch(e){/*ignore*/}
  }
  function restoreSnapshot(i){
    if(i<0 || i>=snapshots.length) return;
    const img = new Image();
    img.onload = ()=> { ctx.clearRect(0,0,canvas.width,canvas.height); ctx.drawImage(img,0,0,canvas.width,canvas.height); };
    img.src = snapshots[i];
  }
  saveSnapshot(); // initial

  // --- Recording model ---
  // recording object: { events: [ {type:'start'|'move'|'end', t:ms, tool:, color:, size:, opacity:, x:, y:... } ], duration: ms }
  let recording = null; // currently recording object
  let isRecording = false;
  let recordStartTime = 0;

  // playback state
  let playback = null; // {script, startTime, timerIds[], pausedAt, playing}
  let playbackTimerIds = [];

  // helpers
  function currentMs(){ return performance.now(); }

  // start a recording
  function startRecording(){
    recording = { events: [], duration:0 };
    isRecording = true;
    recordStartTime = currentMs();
    recordBtn.disabled = true;
    stopRecBtn.disabled = false;
    playBtn.disabled = true;
    exportBtn.disabled = true;
    status.textContent = 'Recording...';
  }

  function stopRecording(){
    if(!isRecording) return;
    isRecording = false;
    recording.duration = Math.max(0, currentMs() - recordStartTime);
    recordBtn.disabled = false;
    stopRecBtn.disabled = true;
    playBtn.disabled = recording.events.length > 0 ? false : true;
    exportBtn.disabled = recording.events.length > 0 ? false : true;
    status.textContent = `Recorded ${Math.round(recording.duration)} ms`;
  }

  // push event to recording (only if isRecording)
  function pushEvent(ev){
    if(!isRecording || !recording) return;
    const t = Math.round(currentMs() - recordStartTime);
    recording.events.push(Object.assign({ t }, ev));
  }

  // --- Pointer drawing (simple smoothing omitted for brevity) ---
  function applyStrokeSettings(ctxLocal, evTool, evColor, evSize, evOpacity){
    if(evTool === 'eraser'){
      ctxLocal.globalCompositeOperation = 'destination-out';
      ctxLocal.globalAlpha = 1;
      ctxLocal.strokeStyle = 'rgba(0,0,0,1)';
    } else {
      ctxLocal.globalCompositeOperation = 'source-over';
      ctxLocal.globalAlpha = evOpacity;
      ctxLocal.strokeStyle = evColor;
    }
    ctxLocal.lineCap = 'round';
    ctxLocal.lineJoin = 'round';
    ctxLocal.lineWidth = evSize;
  }

  function drawSegment(prev, curr, evTool, evColor, evSize, evOpacity){
    applyStrokeSettings(ctx, evTool, evColor, evSize, evOpacity);
    ctx.beginPath();
    ctx.moveTo(prev.x, prev.y);
    ctx.lineTo(curr.x, curr.y);
    ctx.stroke();
  }

  // pointer events
  canvas.addEventListener('pointerdown', (e)=>{
    // ignore right-click
    if(e.button && e.button !== 0) return;
    canvas.setPointerCapture && canvas.setPointerCapture(e.pointerId);
    drawing = true;
    lastPointerId = e.pointerId;
    const pos = getPos(e);
    points = [pos];

    // push start event if recording
    pushEvent({ type:'start', tool, color, size, opacity, x:pos.x, y:pos.y });

    // immediate dot
    applyStrokeSettings(ctx, tool, color, size, opacity);
    ctx.beginPath();
    ctx.moveTo(pos.x, pos.y);
    ctx.lineTo(pos.x+0.01, pos.y+0.01);
    ctx.stroke();
    e.preventDefault();
  }, {passive:false});

  canvas.addEventListener('pointermove', (e)=>{
    if(!drawing || e.pointerId !== lastPointerId) return;
    const pos = getPos(e);
    const prev = points[points.length-1];
    points.push(pos);
    drawSegment(prev, pos, tool, color, size, opacity);

    // push move event
    pushEvent({ type:'move', x:pos.x, y:pos.y });
    e.preventDefault();
    // update laser position if laser active
    if(laserActive) {
      positionLaser(e.clientX, e.clientY);
    }
  }, {passive:false});

  window.addEventListener('pointerup', (e)=>{
    if(!drawing || e.pointerId !== lastPointerId) return;
    drawing = false;
    canvas.releasePointerCapture && canvas.releasePointerCapture(e.pointerId);
    // push end event
    const pos = points[points.length-1] || getPos(e);
    pushEvent({ type:'end', x:pos.x, y:pos.y });
    saveSnapshot();
  }, {passive:false});

  // helper to get pointer position relative to canvas
  function getPos(e){
    const r = canvas.getBoundingClientRect();
    return { x: e.clientX - r.left, y: e.clientY - r.top };
  }

  // --- Tool toggles ---
  function setTool(t){
    tool = t;
    [penBtn, highlighterBtn, eraserBtn, textBtn].forEach(b => b.classList.remove('active'));
    if(t==='pen') penBtn.classList.add('active');
    if(t==='highlighter') highlighterBtn.classList.add('active');
    if(t==='eraser') eraserBtn.classList.add('active');
    if(t==='text') textBtn.classList.add('active');
    // cursor
    canvas.style.cursor = (t==='text' ? 'text' : 'crosshair');
  }
  penBtn.addEventListener('click', ()=> setTool('pen'));
  highlighterBtn.addEventListener('click', ()=> setTool('highlighter'));
  eraserBtn.addEventListener('click', ()=> setTool('eraser'));
  textBtn.addEventListener('click', ()=> setTool('text'));

  colorInput.addEventListener('input', (e)=> { color = e.target.value; });
  sizeInput.addEventListener('input', (e)=> { size = Number(e.target.value); });
  opacityInput.addEventListener('input', (e)=> { opacity = Number(e.target.value); });

  // --- Recording UI wiring ---
  recordBtn.addEventListener('click', ()=> {
    // can't record while playing
    if(playback && playback.playing) return alert('Stop playback before recording.');
    startRecording();
  });
  stopRecBtn.addEventListener('click', ()=> stopRecording());

  // Export/import
  exportBtn.addEventListener('click', ()=>{
    if(!recording) return;
    const blob = new Blob([JSON.stringify(recording)], {type:'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = 'whiteboard-recording.json';
    document.body.appendChild(a); a.click(); a.remove();
    URL.revokeObjectURL(url);
  });

  importFile.addEventListener('change', (ev)=> {
    const f = ev.target.files[0];
    if(!f) return;
    const reader = new FileReader();
    reader.onload = (e) => {
      try{
        const data = JSON.parse(e.target.result);
        if(data && Array.isArray(data.events)){
          // stop any playing/recording
          stopPlayback();
          isRecording = false; recording = null;
          loadRecordingToMemory(data);
          status.textContent = `Imported ${data.events.length} events (${Math.round(data.duration||0)} ms)`;
          playBtn.disabled = false; exportBtn.disabled = false;
        } else alert('Invalid recording file.');
      }catch(err){ alert('Failed to parse file: ' + err.message); }
    };
    reader.readAsText(f);
    // clear input for next import
    ev.target.value = '';
  });

  // Helper to load recording into memory variable `recordingMemory`
  let recordingMemory = null;
  function loadRecordingToMemory(obj){
    recordingMemory = obj;
  }

  // When we finish a recording we also copy it to memory for playback
  function stopRecording(){
    if(!isRecording) return;
    recording.duration = Math.max(0, currentMs() - recordStartTime);
    recordingMemory = recording;
    isRecording = false;
    recordBtn.disabled = false;
    stopRecBtn.disabled = true;
    playBtn.disabled = recordingMemory.events.length === 0;
    exportBtn.disabled = recordingMemory.events.length === 0;
    status.textContent = `Recorded ${Math.round(recording.duration)} ms`;
  }

  // --- Playback implementation ---
  function playRecording(){
    if(!recordingMemory || !recordingMemory.events || recordingMemory.events.length===0) return;
    if(isRecording) { alert('Stop recording before playback'); return; }
    // prepare canvas: clear (optionally) and play on top
    // We'll create a clean canvas snapshot (white) then replay strokes on it
    stopPlayback(); // ensure no previous timers
    playback = { script: recordingMemory, startTime: currentMs(), playing: true, pausedAt:0 };
    setPlaybackUI(true);
    // Clear canvas to white and optionally remove existing text notes (we leave text boxes intact)
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,canvas.width,canvas.height);

    // We will iterate events and schedule them with setTimeout using event.t
    const evs = recordingMemory.events;
    let penState = null; // track last position for continuous drawing
    let scheduled = [];

    // Build a small replay engine: when start event => move pen to pos; move events => draw
    for(let i=0;i<evs.length;i++){
      const ev = evs[i];
      const when = ev.t; // ms relative to start
      const id = setTimeout(() => {
        if(!playback || !playback.playing) return;
        // handle event
        if(ev.type === 'start'){
          penState = { x: ev.x, y: ev.y, tool: ev.tool, color: ev.color, size: ev.size, opacity: ev.opacity };
          // draw a dot
          applyStrokeSettings(ctx, penState.tool, penState.color, penState.size, penState.opacity);
          ctx.beginPath();
          ctx.moveTo(penState.x, penState.y);
          ctx.lineTo(penState.x+0.01, penState.y+0.01);
          ctx.stroke();
        } else if(ev.type === 'move'){
          if(!penState) return;
          const prev = { x: penState.x, y: penState.y };
          const curr = { x: ev.x, y: ev.y };
          drawSegment(prev, curr, penState.tool, penState.color, penState.size, penState.opacity);
          penState.x = curr.x; penState.y = curr.y;
        } else if(ev.type === 'end'){
          penState = null;
        }
        // update progress bar
        const progress = Math.min(1, (currentMs() - playback.startTime) / (playback.script.duration || 1));
        playbar.style.width = (progress*100)+'%';
        if(progress >= 1){
          // playback finished
          setTimeout(() => { stopPlayback(); status.textContent = 'Playback finished'; }, 20);
        }
      }, when);
      scheduled.push(id);
    }
    playback.timerIds = scheduled;
    status.textContent = 'Playing...';
  }

  function pausePlayback(){
    if(!playback || !playback.playing) return;
    // clear scheduled timers and store pausedAt
    playback.pausedAt = currentMs() - playback.startTime;
    playback.playing = false;
    playback.timerIds.forEach(id => clearTimeout(id));
    playback.timerIds = [];
    setPlaybackUI(false, true);
    status.textContent = 'Paused';
  }

  function resumePlayback(){
    if(!playback || playback.playing) return;
    // Resume by scheduling remaining events with adjusted times
    const script = playback.script;
    playback.startTime = currentMs() - (playback.pausedAt || 0);
    playback.playing = true;
    const scheduled = [];
    for(let ev of script.events){
      const when = ev.t - (playback.pausedAt || 0);
      if(when <= 0) {
        // already past: apply immediately
        if(ev.type === 'start'){
          // create small dot
          applyStrokeSettings(ctx, ev.tool, ev.color, ev.size, ev.opacity);
          ctx.beginPath(); ctx.moveTo(ev.x, ev.y); ctx.lineTo(ev.x+0.01, ev.y+0.01); ctx.stroke();
        } else if(ev.type === 'move'){
          // draw this move immediately - best-effort (we don't have prev here)
          // skip as we can't reliably draw without state; playback resumes normally for future events
        }
        continue;
      }
      const id = setTimeout(() => {
        if(!playback || !playback.playing) return;
        // handle event similarly to playRecording loop
        if(ev.type === 'start'){
          // small dot
          applyStrokeSettings(ctx, ev.tool, ev.color, ev.size, ev.opacity);
          ctx.beginPath(); ctx.moveTo(ev.x, ev.y); ctx.lineTo(ev.x+0.01, ev.y+0.01); ctx.stroke();
          // store ephemeral penState? For simplicity we only rely on move events drawing sequentially
        } else if(ev.type === 'move'){
          // draw a short segment between this move and previous recorded move (approx)
          // To keep it simple, draw a tiny line to the given coordinates
          applyStrokeSettings(ctx, ev.tool, ev.color, ev.size, ev.opacity);
          ctx.beginPath(); ctx.moveTo(ev.x-0.5, ev.y-0.5); ctx.lineTo(ev.x, ev.y); ctx.stroke();
        } else if(ev.type === 'end'){
          // nothing special
        }
        const progress = Math.min(1, (currentMs() - playback.startTime) / (playback.script.duration || 1));
        playbar.style.width = (progress*100)+'%';
        if(progress >= 1){
          setTimeout(() => { stopPlayback(); status.textContent = 'Playback finished'; }, 20);
        }
      }, when);
      scheduled.push(id);
    }
    playback.timerIds = scheduled;
    setPlaybackUI(true);
    status.textContent = 'Playing...';
  }

  function stopPlayback(){
    if(!playback) { // clear UI
      playbar.style.width = '0%';
      playBtn.disabled = recordingMemory ? false : true;
      pauseBtn.disabled = true;
      stopPlayBtn.disabled = true;
      return;
    }
    // clear timers
    if(playback.timerIds) playback.timerIds.forEach(id => clearTimeout(id));
    playback = null;
    playbar.style.width = '0%';
    setPlaybackUI(false);
    status.textContent = 'Ready';
    // after playback we take snapshot of resulting canvas so undo works
    saveSnapshot();
  }

  // UI toggles for playback state
  function setPlaybackUI(isPlaying, isPaused=false){
    playBtn.disabled = isPlaying;
    pauseBtn.disabled = !isPlaying && !isPaused;
    stopPlayBtn.disabled = !isPlaying && !isPaused;
    // while playing, disable drawing controls
    const disabled = !!isPlaying || isPaused;
    penBtn.disabled = disabled; highlighterBtn.disabled = disabled; eraserBtn.disabled = disabled; textBtn.disabled = disabled;
    colorInput.disabled = disabled; sizeInput.disabled = disabled; opacityInput.disabled = disabled;
  }

  playBtn.addEventListener('click', ()=> {
    if(!recordingMemory) { alert('No recording loaded. Record or import first.'); return; }
    playRecording();
  });
  pauseBtn.addEventListener('click', ()=> {
    if(playback && playback.playing) pausePlayback();
    else if(playback && !playback.playing) resumePlayback();
  });
  stopPlayBtn.addEventListener('click', ()=> stopPlayback());

  // Load the just-finished recording into memory automatically
  // Note: we already set recordingMemory when stopping recording

  // --- Laser pointer ---
  let laserActive = false;
  laserBtn.addEventListener('click', ()=>{
    laserActive = !laserActive;
    laserEl.style.display = laserActive ? 'block' : 'none';
    laserBtn.classList.toggle('active', laserActive);
    // if active we should follow pointer
    status.textContent = laserActive ? 'Laser on' : 'Laser off';
  });

  function positionLaser(clientX, clientY){
    const r = wrap.getBoundingClientRect();
    laserEl.style.left = (clientX - r.left) + 'px';
    laserEl.style.top = (clientY - r.top) + 'px';
  }
  // Move laser on pointer move anywhere inside wrap
  wrap.addEventListener('pointermove', (e)=>{
    if(laserActive){
      positionLaser(e.clientX, e.clientY);
    }
  });

  // Also show laser briefly when clicking Play to simulate presenter laser (optional)
  // we won't do that by default.

  // --- Import button wiring (trigger file input) ---
  importBtn.addEventListener('click', ()=> importFile.click());

  // Utility: load recording from last recording variable (stopRecording sets recordingMemory)
  // expose stopRecording to inner scope; earlier stopRecording defined twice ‚Äî ensure final binding:
  // (we replaced earlier with this one; if duplication occurs browsers use last definition)

  // Safety: disable drawing if playback active
  // done via setPlaybackUI

  // small UX: disable play until recording exists
  playBtn.disabled = true; pauseBtn.disabled = true; stopPlayBtn.disabled = true; exportBtn.disabled = true;

  // Make sure the recordingMemory is set when a recording finishes
  // (stopRecording sets it; earlier we had two stopRecording functions in initial code, but here the latest is used.)

  // Provide keyboard shortcuts for convenience
  window.addEventListener('keydown', (e)=>{
    if((e.ctrlKey || e.metaKey) && e.key === 'r'){ e.preventDefault(); recordBtn.click(); }
    if((e.ctrlKey || e.metaKey) && e.key === 'p'){ e.preventDefault(); playBtn.click(); }
  });

  // Ensure canvas background is white initially
  ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,canvas.width,canvas.height);

  // When recording finishes the 'recording' variable holds the session, and recordingMemory references it
  // Implementation of stopRecording above sets recordingMemory.

  // Edge-case: if user recorded then navigated away and returns, they lose recording (browser memory). Use Export to persist.

  // Quick demo helper: load last recording into memory when created
  // (the stopRecording handler already does this)

  // That's it ‚Äî the essentials are provided above.
})();
</script>
</body>
</html>
