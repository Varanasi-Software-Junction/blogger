
   

<img  class="crx_avatar" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEglwaii2_xBr47JtUxESk3iekPLl1TSI5B6RuwqNOs_8zk9iGlLqw3d_WprAhKKp3m9F1eO4XBh_JfU_jj6Ad759bHWsqU0evz1SdsG_XBJPc7nXmkbGHO2glvshLTd0fOaKlIGfEVHlEeltJcg2Azc70rVoswRtvH-QiohpHrAuuPEE1uwA9CToBM9foE/s16000/me.jpg" alt="Champak's implementation of Bubble Sort"/>
  
  <br><br>

<!-- Bubble Sort Visualizer — finalized border color/thickness + event log -->
<style>
  /* basic styles (kept minimal so you can drop into Blogger) */
  #crx_container { position:relative; width:100%; height:220px; border:2px solid #333; margin-top:10px; overflow-x:auto; padding:10px; box-sizing:border-box; background:#fafafa; }
  .crx_box { position:absolute; width:56px; height:56px; display:flex; align-items:center; justify-content:center; border-radius:8px; font-weight:700; user-select:none; box-shadow:0 6px 14px rgba(0,0,0,0.08); transition: transform 0.35s ease, box-shadow 0.35s ease, left 0.25s ease; }
  .crx_box .idx { position:absolute; right:-10px; top:-10px; font-size:10px; background:rgba(255,255,255,0.85); padding:2px 4px; border-radius:6px; border:1px solid rgba(0,0,0,0.06); font-weight:600; }

  /* highlight used during compare */
  .crx_highlight { transform: scale(1.08); box-shadow: 0 10px 26px rgba(11,99,212,0.24) !important; }

  /* Finalized box: deeper green and thicker */
  .crx_final {
    border: 4px solid #0b6623 !important; /* deeper green, thicker */
    box-shadow: 0 8px 20px rgba(0,0,0,0.08) !important;
  }

  /* Speech bar (keeps visual from original) */
  #crx_speechBar { margin-top:16px; padding:10px; background:#0b63d4; color:#fff; border-radius:6px; min-height:46px; display:flex; flex-direction:column; gap:6px; }
  #crx_speechCurrent { font-size:18px; font-weight:700; text-align:center; letter-spacing:0.4px; }
  #crx_speechQueue { font-size:13px; opacity:0.95; text-align:center; }

  /* Event log */
  #crx_eventLog { min-width:320px; max-width:720px; box-sizing:border-box; padding:8px; border-radius:6px; border:1px solid #ccc; background:#fff; font-family:monospace; }
  #crx_controls_wrap { display:flex; gap:12px; flex-wrap:wrap; align-items:center; }
  .crx_log_controls { display:flex; gap:8px; align-items:center; }
  .crx_legend { background:#f3f7f5; border:1px solid rgba(11,102,35,0.08); padding:8px 10px; border-radius:6px; color:#083d26; font-size:13px; max-width:720px; }
</style>

<div style="font-family:Inter,system-ui,-apple-system,'Segoe UI',Roboto,Arial; color:#222; line-height:1.55;">
  <h2 style="color:#0a66c2; margin-bottom:6px;">Bubble Sort Visualizer — three modes + early exit</h2>

  <div id="crx_controls_wrap">
    <div id="crx_controls" style="margin-bottom:12px; display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
      <label style="font-weight:700;">Numbers:</label>
      <input id="crx_numbers" type="text" value="1,6,0,1,1,9,7,0" style="min-width:320px; padding:8px; border-radius:6px; border:1px solid #ccc;"></input>

      <button id="crx_createBtn" style="padding:8px 12px; border-radius:6px; border:1px solid #0b63d4; background:#0b63d4; color:#fff; cursor:pointer;">Create Boxes</button>
      <button id="crx_sortBtn" style="padding:8px 12px; border-radius:6px; border:1px solid #0b63d4; background:#0b63d4; color:#fff; cursor:pointer;">Run Bubble Sort</button>

      <label style="margin-left:8px; display:flex; gap:6px; align-items:center;">
        <input id="crx_speechToggle" type="checkbox" checked="checked"></input>
        <span style="font-weight:600;">Speak (comparisons & swaps)</span>
      </label>

      <label style="margin-left:8px; display:flex; gap:6px; align-items:center;">
        <span style="font-weight:600;">Mode:</span>
        <select id="crx_mode" style="padding:6px 8px; border-radius:6px; border:1px solid #ccc;">
          <option value="ltr">Left → Right</option>
          <option value="rtl">Right → Left</option>
          <option value="alt">Alternating (L→R then R→L)</option>
        </select>
      </label>
    </div>

    <!-- Legend explaining the finalized border meaning -->
    <div class="crx_legend" title="Finalized element meaning">
      <strong>What the dark-green border means:</strong>
      <div style="margin-top:6px; font-size:13px;">
        A box with a <span style="border-bottom:2px solid #0b6623; padding-bottom:1px;">dark-green border</span> is <em>finalized</em> — it has reached its correct, sorted position and will not move again. Boxes get finalized one-by-one as the algorithm finishes each pass.
      </div>
    </div>
  </div>

  <div id="crx_container">
    <div class="crx_spacer" style="height:160px;"></div>
  </div>

  <div style="display:flex; gap:12px; margin-top:12px; align-items:flex-start; flex-wrap:wrap;">
    <div style="flex:1; min-width:320px;">
      <div id="crx_speechBar" aria-live="polite">
        <div id="crx_speechCurrent">Ready...</div>
        <div id="crx_speechQueue"></div>
      </div>
    </div>

    <div style="min-width:320px; max-width:720px;">
      <label style="display:block; font-weight:700; margin-bottom:6px;">Event Log (comparisons, swaps, finalizations):</label>
      <div style="display:flex; gap:8px; align-items:center;">
        <select id="crx_eventLog" multiple size="8"></select>
        <div class="crx_log_controls">
          <button id="crx_clearLog" style="padding:8px 10px; border-radius:6px; border:1px solid #999; background:#fff; cursor:pointer;">Clear Log</button>
        </div>
      </div>
      <div style="font-size:12px; color:#666; margin-top:6px;">The top (selected) entry is the newest event; the log records every compare and swap as the visual run proceeds.</div>
    </div>
  </div>
</div>

<script>
(function(){
  // DOM refs
  const container = document.getElementById('crx_container');
  const createBtn = document.getElementById('crx_createBtn');
  const sortBtn = document.getElementById('crx_sortBtn');
  const input = document.getElementById('crx_numbers');
  const speechToggle = document.getElementById('crx_speechToggle');
  const speechCurrent = document.getElementById('crx_speechCurrent');
  const speechQueueDiv = document.getElementById('crx_speechQueue');
  const modeSelect = document.getElementById('crx_mode');
  const eventLog = document.getElementById('crx_eventLog');
  const clearLogBtn = document.getElementById('crx_clearLog');

  // state
  let boxes = [];    // DOM elements
  let values = [];   // numeric values
  let busy = false;
  let needRecenter = false;
  let phraseQueue = [];

  // layout/timings
  const spacing = 80;
  const ypos = 60;
  const stageMs = 420;
  const swapTotalMs = stageMs * 3;
  const compareMs = 900; // comparison duration

  // log cap
  const LOG_CAP = 500;

  // helpers: color mapping
  function numberToColorMagnitude(magnitude, maxAbs) {
    if (maxAbs === 0) return { r: 80, g: 130, b: 220 };
    let t = magnitude / maxAbs;
    return {
      r: Math.round(t * 255),
      g: Math.round((1 - Math.abs(t - 0.5) * 2) * 255),
      b: Math.round((1 - t) * 255)
    };
  }
  function invertColor({ r, g, b }) { return { r: 255 - r, g: 255 - g, b: 255 - b }; }
  function rgbToString({ r, g, b }) { return `rgb(${r},${g},${b})`; }

  // centering
  function computeOffset() {
    const totalWidth = values.length * spacing;
    const containerWidth = container.clientWidth;
    return Math.max(0, (containerWidth - totalWidth) / 2);
  }
  function slotLeft(index) { return computeOffset() + index * spacing; }

  // speech UI
  function updateSpeechBarUI() {
    if (phraseQueue.length === 0) {
      speechCurrent.textContent = 'Ready...';
      speechQueueDiv.innerHTML = '';
      return;
    }
    speechCurrent.textContent = phraseQueue[0] || '';
    if (phraseQueue.length > 1) {
      const upcoming = phraseQueue.slice(1, 7).map((p, i) => `<span class="upcoming" style="display:block; color: rgba(255,255,255,0.9);">${i+1}. ${escapeHtml(p)}</span>`).join('');
      speechQueueDiv.innerHTML = upcoming;
    } else {
      speechQueueDiv.innerHTML = '';
    }
  }
  function escapeHtml(s) { return String(s).replace(/[&<>"']/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }
  function enqueuePhrase(phrase){ phraseQueue.push(phrase); updateSpeechBarUI(); }
  function dequeuePhrase(){ phraseQueue.shift(); updateSpeechBarUI(); }

  // event log functions
  function logEvent(text) {
    // newest at bottom; we'll keep scroll to bottom by selecting last index
    const opt = document.createElement('option');
    opt.innerHTML = text;
    eventLog.add(opt, 0); // add at top so newest appear at top
    // Ensure cap
    while (eventLog.options.length > LOG_CAP) {
      eventLog.remove(eventLog.options.length - 1);
    }
    // select first (newest) so it shows
    if (eventLog.options.length) {
      eventLog.selectedIndex = 0;
    }
  }
  function clearLog() {
    eventLog.innerHTML = '';
  }

  // speak with duration target
  function speakPhraseForDuration(phrase, targetMs){
    enqueuePhrase(phrase);
    return new Promise(resolve => {
      if (!speechToggle.checked || typeof speechSynthesis === 'undefined') {
        setTimeout(()=>{ dequeuePhrase(); resolve(); }, Math.max(30, targetMs));
        return;
      }
      const words = phrase.trim().split(/\s+/).length || 1;
      const estMsAtRate1 = (words / 3) * 1000;
      let rate = estMsAtRate1 / targetMs;
      if (rate < 0.35) rate = 0.35; if (rate > 2.5) rate = 2.5;
      const u = new SpeechSynthesisUtterance(phrase);
      u.rate = rate;
      const voices = speechSynthesis.getVoices();
      if (voices && voices.length) {
        const v = voices.find(v => /en-|english/i.test(v.name)) || voices[0];
        if (v) u.voice = v;
      }
      u.onend = ()=>{ dequeuePhrase(); resolve(); };
      u.onerror = ()=>{ dequeuePhrase(); resolve(); };
      speechSynthesis.speak(u);
    });
  }

  // utilities
  function delay(ms){ return new Promise(r=>setTimeout(r, ms)); }
  function refreshIndices(){ boxes.forEach((b,i)=>{ const lbl=b.querySelector('.idx'); if(lbl) lbl.textContent=i; }); }
  function currentLeftRelToContainer(elem){
    const rect = elem.getBoundingClientRect();
    const cont = container.getBoundingClientRect();
    return rect.left - cont.left + container.scrollLeft;
  }

  // create boxes
  function createBoxes(){
    const raw = input.value.split(',').map(s=>s.trim()).filter(s=>s.length>0);
    const parsed = raw.map(s=>Number(s)).filter(n=>!Number.isNaN(n));
    if (parsed.length===0){ alert('Enter at least one number'); return; }
    container.innerHTML = '<div class="crx_spacer" style="height:160px;"></div>';
    boxes=[]; values=[];
    const maxAbs = Math.max(...parsed.map(n=>Math.abs(n)));
    parsed.forEach((val, idx)=>{
      const mag = Math.abs(val);
      const posBg = numberToColorMagnitude(mag, maxAbs);
      const posText = invertColor(posBg);
      const bg = val >= 0 ? posBg : posText;
      const fg = val >= 0 ? posText : posBg;

      const box = document.createElement('div');
      box.className = 'crx_box';
      box.textContent = val;
      box.style.position = 'absolute';
      box.style.width = '56px';
      box.style.height = '56px';
      box.style.display = 'flex';
      box.style.alignItems = 'center';
      box.style.justifyContent = 'center';
      box.style.borderRadius = '8px';
      box.style.fontWeight = '700';
      box.style.transition = 'transform 0.35s ease, box-shadow 0.35s ease, left 0.25s ease';
      box.style.userSelect = 'none';
      box.style.boxShadow = '0 6px 14px rgba(0,0,0,0.08)';
      box.style.left = slotLeft(idx) + 'px';
      box.style.top = ypos + 'px';
      box.style.background = rgbToString(bg);
      box.style.color = rgbToString(fg);
      box.style.border = '1px solid rgba(0,0,0,0.06)';

      const lbl = document.createElement('div');
      lbl.className = 'idx';
      lbl.textContent = idx;
      box.appendChild(lbl);

      container.appendChild(box);
      boxes.push(box);
      values.push(val);
    });

    container.style.minWidth = (parsed.length * spacing + 20) + 'px';
    phraseQueue = [];
    updateSpeechBarUI();
    clearLog(); // clear previous events when creating new boxes
    logEvent(`Created ${parsed.length} boxes: [${parsed.join(', ')}]`);
    recenterBoxes();
  }

  // visual helpers
  function addHighlight(el){ if(!el.classList.contains('crx_final')) { el.classList.add('crx_highlight'); el.style.transform='scale(1.08)'; el.style.boxShadow='0 10px 26px rgba(11,99,212,0.24)'; } }
  function removeHighlight(el){ el.classList.remove('crx_highlight'); el.style.transform=''; el.style.boxShadow='0 6px 14px rgba(0,0,0,0.08)'; }

  function commitBoxToSlotWithoutJump(box, targetSlotLeftPx){
    const curLeft = currentLeftRelToContainer(box);
    const fix = curLeft - targetSlotLeftPx;
    box.style.transition = 'none';
    box.style.left = Math.round(targetSlotLeftPx) + 'px';
    box.style.transform = `translate(${Math.round(fix)}px, 0px)`;
    void box.offsetWidth;
    box.style.transform = '';
    void box.offsetWidth;
    box.style.transition = 'transform 0.35s ease, box-shadow 0.35s ease, left 0.25s ease';
  }

  // highlight and speak comparison
  async function highlightAndSpeakCompare(i, j){
    if (i<0||j<0||i>=boxes.length||j>=boxes.length) return;
    const a = boxes[i], b = boxes[j];
    const phrase = `Comparing ${values[i]} and ${values[j]}`;
    // Log the comparison (newest on top)
    logEvent(`Compare: indices ${i} vs ${j} — values ${values[i]} vs ${values[j]}`);
    addHighlight(a); addHighlight(b);
    const sp = speakPhraseForDuration(phrase, compareMs);
    await delay(compareMs);
    removeHighlight(a); removeHighlight(b);
    await sp;
  }

  // swap animation with speech
  async function swapAnimationSpeak(i, j){
    if (i===j) return;
    const boxA = boxes[i], boxB = boxes[j];
    const valA = values[i], valB = values[j];
    const leftA = slotLeft(i), leftB = slotLeft(j);
    const dAB = leftB - leftA, dBA = leftA - leftB;
    const phrase = `Swapping ${valA} and ${valB}`;

    // Log the swap
    logEvent(`Swap: indices ${i} <-> ${j} — values ${valA} <-> ${valB}`);

    const speechPromise = speakPhraseForDuration(phrase, swapTotalMs);

    // up
    boxA.style.transition = `transform ${stageMs/1000}s ease`;
    boxB.style.transition = `transform ${stageMs/1000}s ease`;
    boxA.style.transform = 'translateY(-70px)';
    boxB.style.transform = 'translateY(-70px)';
    await delay(stageMs);

    // cross
    boxA.style.transform = `translate(${dAB}px, -70px)`;
    boxB.style.transform = `translate(${dBA}px, -70px)`;
    await delay(stageMs);

    // down
    boxA.style.transform = `translate(${dAB}px, 0px)`;
    boxB.style.transform = `translate(${dBA}px, 0px)`;
    await delay(stageMs);

    await speechPromise;

    // commit positions without jump
    const targetLeftA = slotLeft(j);
    const targetLeftB = slotLeft(i);
    commitBoxToSlotWithoutJump(boxA, targetLeftA);
    commitBoxToSlotWithoutJump(boxB, targetLeftB);

    // swap logical arrays
    [boxes[i], boxes[j]] = [boxes[j], boxes[i]];
    [values[i], values[j]] = [values[j], values[i]];
    refreshIndices();

    if (needRecenter) { needRecenter=false; recenterBoxes(); }
  }

  // recenter
  function recenterBoxes(){
    if (boxes.length===0) return;
    if (busy) { needRecenter=true; return; }
    boxes.forEach((box, idx)=>{ box.style.transition='none'; box.style.left = Math.round(slotLeft(idx)) + 'px'; });
    void container.offsetWidth;
    boxes.forEach(box=>{ box.style.transition = 'transform 0.35s ease, box-shadow 0.35s ease, left 0.25s ease'; });
  }

  // bubble sort driver with three modes and early exit when no swaps in a full pass
  async function bubbleSort(){
    if (busy) return;
    if (values.length < 2) return;
    busy = true; createBtn.disabled = true; sortBtn.disabled = true;

    const n = values.length;
    let pass = 0;
    let swappedThisPass = true;

    logEvent(`Start sorting (mode=${modeSelect.value})`);

    while (pass < n - 1 && swappedThisPass) {
      swappedThisPass = false;
      // determine direction for this pass
      const mode = modeSelect.value; // 'ltr', 'rtl', 'alt'
      let dir = 'ltr';
      if (mode === 'ltr') dir = 'ltr';
      else if (mode === 'rtl') dir = 'rtl';
      else if (mode === 'alt') dir = (pass % 2 === 0) ? 'ltr' : 'rtl';

      logEvent(`Pass ${pass + 1} — direction: ${dir.toUpperCase()}`);

      if (dir === 'ltr') {
        // i = 0 .. n-2-pass
        for (let i = 0; i < n - 1 - pass; i++) {
          await highlightAndSpeakCompare(i, i+1);
          if (values[i] > values[i+1]) {
            await swapAnimationSpeak(i, i+1);
            swappedThisPass = true;
          }
        }
        // mark the element at position (n-1-pass) as finalized
        const finalizedIdx = n - 1 - pass;
        if (boxes[finalizedIdx]) {
          removeHighlight(boxes[finalizedIdx]); // remove any blue highlight
          boxes[finalizedIdx].classList.add('crx_final');
          logEvent(`Finalized: index ${finalizedIdx} — value ${values[finalizedIdx]}`);
        }
      } else {
        // dir === 'rtl'
        // i = n-1 .. 1+pass
        for (let i = n - 1; i > pass; i--) {
          await highlightAndSpeakCompare(i, i-1);
          if (values[i-1] > values[i]) {
            // swap positions i-1 and i (which are adjacent)
            await swapAnimationSpeak(i-1, i);
            swappedThisPass = true;
          }
        }
        // mark the element at position (pass) as finalized
        const finalizedIdx = pass;
        if (boxes[finalizedIdx]) {
          removeHighlight(boxes[finalizedIdx]);
          boxes[finalizedIdx].classList.add('crx_final');
          logEvent(`Finalized: index ${finalizedIdx} — value ${values[finalizedIdx]}`);
        }
      }

      pass++;
      // If no swap happened in this whole pass, early exit
      if (!swappedThisPass) {
        logEvent(`No swaps in pass ${pass}; early exit`);
        break;
      }
    }

    // After loop finishes, mark any remaining items as finalized (in case early exit left some)
    boxes.forEach((b, idx) => {
      removeHighlight(b);
      if (!b.classList.contains('crx_final')) {
        b.classList.add('crx_final');
        logEvent(`Finalized (end): index ${idx} — value ${values[idx]}`);
      }
    });

    busy = false; createBtn.disabled = false; sortBtn.disabled = false;

    // small sorted highlight flash (kept for familiarity)
    boxes.forEach(b => { b.classList.add('crx_highlight'); });
    setTimeout(()=> boxes.forEach(b => b.classList.remove('crx_highlight')), 600);

    phraseQueue = ['Sorting complete!']; updateSpeechBarUI();
    setTimeout(()=>{ phraseQueue = []; updateSpeechBarUI(); }, 1600);

    alert('Sorting complete!');
  }

  // events
  createBtn.addEventListener('click', () => {
    createBoxes();
  });
  sortBtn.addEventListener('click', bubbleSort);

  clearLogBtn.addEventListener('click', ()=>{ clearLog(); logEvent('Log cleared'); });

  // recenter on resize
  let resizeTimer = null;
  window.addEventListener('resize', ()=>{ clearTimeout(resizeTimer); resizeTimer = setTimeout(()=>{ if (busy) needRecenter=true; else recenterBoxes(); }, 120); });

  // init
  createBoxes();

})();
</script>
